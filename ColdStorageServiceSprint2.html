<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<script type="text/javascript" src="../css/issStyle.js"></script>
-->

<link rel="stylesheet" type="text/css" href="./common/sprintstyle.css">

<head>
    <title>Sprint2</title>
</head>

<body>

    <div id="top">

        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE<font size="5"></font>
        </h1>

    </div>

    <div class="body">

        <h2>Introduction</h2>
        Lo <b>Sprint2</b> è il naturale proseguo di quanto realizzato nello Sprint1. Dopo aver delineato, realizzato e
        testato il Core
        Business del sistema, composto dal <b>ColdStorageService</b> e <b>Transport Trolley</b>, possiamo prosegurie
        sostituendo il simulatore della <b>ServiceAccessGUI</b> con il componente
        reale.

        <h2>Requirements</h2>

        <div class="remark">
            <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Descrizione del
                TemaFinale23</a><br>

            <bc>Goals Sprint 2</bc>
            <ol>
                <li>Identificare ed analizzare tutti i problemi relativi ai requisiti che coinvolgono la
                    <b>ServiceAccessGUI</b>
                </li>
                <li>Integrare al sistema realizzato nello Sprint1 la <b>ServiceAccessGUI</b>, che permette l'interazione
                    tra il conducente del <b>Fridge Truck</b> ed il servizio <b>ColdStorageService</b></li>
                <li>Realizzare l'interfaccia grafica</li>
                <li>Testare il sistema</li>
            </ol>
        </div>

        <h2>Requirement analysis</h2>

        <h4>Chiarimenti del committente</h4>
        L'interazione con il committente ha permesso di chiarire alcuni aspetti del progetto:
        <ul>
            <li>Cosa significa GUI unica?</li>
            <li>I conducenti dei <b>Fridge Truck</b> inseriscono i <b>ticket</b> solo quando si trovano davanti alla <b>INDOOR</b></li>
        </ul>
        I <b>Ticket</b>, nel mondo odierno, vengono utilizzati come metodo di autenticazione e validazione; esattamente come nel caso di questo progetto. <br>
        Per prevenire l'utilizzo non autorizzato di un ticket da parte di un'altra persona, sono adottate diverse misure di sicurezza, tra cui:
        <ul>
            <li>Crittografia: I ticket possono essere crittografati per proteggere le informazioni contenute al loro interno e impedire la loro alterazione o contraffazione.</li>
            <li>Protezione dei canali di comunicazione: I canali di comunicazione utilizzati per trasmettere i ticket devono essere protetti tramite cifratura e altri meccanismi di sicurezza per prevenire il furto o l'intercettazione dei ticket.</li>
            <li>Controllo delle autorizzazioni: I server o i sistemi che ricevono i ticket devono verificare che il ticket contenga le autorizzazioni necessarie per accedere alle risorse o ai servizi richiesti.</li>
            <li>Firma digitale: I ticket possono essere firmati digitalmente per garantire l'autenticità e l'integrità delle informazioni contenute al loro interno.</li>
            <li>Validità limitata nel tempo: I ticket possono avere una scadenza dopo la quale non sono più validi. Questo limita il periodo in cui possono essere utilizzati in modo sicuro.</li>
            <li>Gestione delle sessioni: I ticket possono essere associati a una sessione utente. Il server tiene traccia dello stato della sessione e invalida il ticket quando la sessione termina o viene disconnessa.</li>
            <li>Token a un solo uso (One-Time Token): I ticket possono essere generati come token a un solo uso, che diventa invalido dopo essere stato utilizzato una volta. Questo riduce il rischio di riproduzione o riutilizzo dei ticket.</li>
            <li>Controllo dell'IP di origine: I server possono verificare che l'IP di origine delle richieste corrisponda all'IP registrato nel ticket. Se l'IP non corrisponde, il ticket potrebbe essere considerato non valido.</li>
            <li>Controllo dell'User-Agent: I server possono verificare che l'User-Agent del client corrisponda a quello registrato nel ticket. Se l'User-Agent non corrisponde, il ticket potrebbe essere considerato non valido.</li>
            <li>Token di accesso a lunga durata e token di aggiornamento: In alcuni casi, possono essere utilizzati token di accesso a lunga durata o token di aggiornamento per ottenere nuovi ticket o estendere la validità dei ticket esistenti. Questi token richiedono un processo di autenticazione aggiuntivo per ottenere un nuovo ticket.</li>
            <li>Monitoraggio delle attività: I sistemi possono monitorare le attività associate a un ticket, inclusi gli accessi, le richieste e le operazioni eseguite. Questo consente di rilevare comportamenti anomali o sospetti e prendere le misure necessarie.</li>
            <li>Revoca dei ticket: In caso di compromissione o sospetto di utilizzo non autorizzato, i ticket possono essere revocati in modo proattivo per impedire ulteriori accessi non autorizzati. Ciò richiede un sistema di gestione dei ticket che consenta la revoca e la disattivazione dei ticket in modo tempestivo.</li>
            <li>Protezione fisica e sicurezza dei server: I server che gestiscono i ticket devono essere adeguatamente protetti fisicamente e devono seguire le migliori pratiche di sicurezza informatica per prevenire accessi non autorizzati o compromissioni dei ticket.</li>
        </ul>
        Non potendo fare supposizioni sui conducenti dei <b>Fridge Truck</b>, che possono avere più dispositivi, o ad esempio essere più di uno su uno stesso Fridge Truck, si è deciso di generare un Ticket come una sequenza randomica di numeri e lettere. <br>
        In questa maniera anche con un errore di battitura, il conducente non rischia di utilizzare il <b>Ticket</b> di un altro conducente. 

        <h4>Chiarimenti con il committente</h4>
        <ul>
            <li></li>
        </ul>
        

        <h3>Analisi</h3>
        Dai requisiti espressi nel <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Tema
            Finale</a> e dalle analisi
        già effettuate negli Sprint0 e Sprint1, in questo Sprint occorre analizzare le entità:
        <ul>
            <li><b>ServiceAccessGUI</b>, che è una interfaccia grafica per interagire con il servizio</li>
            <li><b>ColdStorageService</b>, per verificare che sia pienamente compatibile con il workflow una volta introdotta la GUI</li>
        </ul>
        <br>
        <br>
        

        Tra i requisiti specificati vi è che la <b>ServiceAccessGUI</b> deve essere in grado di interagire con il servizio <b>ColdStorageService</b>
        effettuando due richieste possibili<br>
        <ul>
            <li>Richiesta di emissione di un <b>ticket</b></li>
            <li>Richiesta di scarico</li>
        </ul>
        In particolare quando un conducente vuole chiedere un <b>ticket</b> specifica anche il peso del carico che è intenzionato a scaricare.<br>
        <br>
        La <b>ServiceAccessGUI</b> deve anche mostrare il peso corrente presente nella <b>ColdRoom</b>.

        <h2>Analisi del Problema</h2>
        Il corpo di questo sprint è il componente <b>ServiceAccessGUI</b>.
        
        <h3>ServiceAccessGUI</h3>
        Svolgendo il ruolo da intermediario tra i conducenti ed il <b>ColdStorageService</b> mostra una interfaccia grafica che permette l'invio di 
        richieste al servizio. Le richieste come da requisiti,utilizzando la terminologia coniata nello sprint1, sono due:<br>
        <ul>
            <li><b>storerequest</b>: richiesta di erogazione di un <b>ticket</b>. Contiene l'informazione del peso <b>FW</b> del carico.</li>
            <li><b>insertticket</b>: richiesta di servizio di scarico presso l'<b>INDOOR</b>. Contiene l'informazione del numero del <b>ticket</b> corrispondente.</li>
        </ul>
        Analizzando tali informazioni si deduce che la <b>ServiceAccessGUI</b> deve essere fornita di:
        <ul>
            <li>un campo per inserire il peso ed un pulsante per effettuare la richiesta <u>storerequest</u>.</li>
            <li>un campo per inserire il <b>ticket</b> ed un pulsante per effettuare la richiesta <u>insertticket</u>.</li>
            <li>un componente che mostri il peso corrente presente nella <b>ColdRoom</b>.</li>
        </ul>
        <div class="remark">
            <div class="keypoint">La <b>ServiceAccessGUI</b> deve essere fornita di un campo per inserire dati ed un pulsante per ognuna delle due richieste
            effettuabili.</div>
        </div>
        Dopo un confronto con il committente lo scenario che si presenta per intergaire con il nostro servizio è scomponibile in due parti:<br>
        <ol>
            <li>I conducenti dei <b>Fridge Truck</b> che si stanno direzionando verso il nostro <b>ColdStorageService</b> sono interessati a capire se 
            c'è posto per scaricare il loro carico, per questo motivo tramite il loro dispositivo mobile accedono ad una GUI che li peremtterà solo di:
            <ul>
                <li>Vedere il peso presente nella <b>ColdRoom</b></li>
                <li>Richiedere l'erogazione di un <b>ticket</b></li>
            </ul>
            </li>
            <li>Una volta che il conducente è arrivato presso il nostro servizio procede all'inserimento del <b>ticket</b>. 
            Inserito il <b>ticket</b> il conducente si mette in coda dove vi sono i conducenti che hanno inserito il <b>ticket</b> prima di lui. 
            Si presuppone che il <b>Fridge Truck</b> impieghi tempo nullo per arrivare alla <b>INDOOR</b> dopo aver inserito il <b>ticket</b>.
            La coda tra l'inserimento del 
            <b>ticket</b> e lo scarico presso la <b>INDOOR</b> è necessaria per evitare che dei <b>ticket</b> scadano per colpa dei ritardi introdotti dal nostro servizio, che 
            forzano il conducente a non poter inserire il <b>ticket</b>, rischiando così di invalidarlo ingiustamente.</li>
        </ol>

        <div class="remark">
            <div class="keypoint">La <b>ServiceAccessGUI</b> verrà visualizzata sui dispositivi mobili dei conducenti</div>
        </div>

        Per evitare che un conducente inserisca il <b>ticket</b> e debba aspettare per un tempo potenzialmente infinito si deve cercare di prevenire una situazione del genere.
        Per farlo vi sono tre proposte:
        <ol>
            <li>Il <b>coldstorageservice</b> deve rifiutare le richieste di <u>storage</u> non solo guardando lo spazio disponibile, ma anche guardando la quantità di <b>ticket</b>
                erogati ancora facenti parte del sistema, e che quindi non hanno ricevuto il relativo <u>chargetaken</u>.</li>
            <li>Quando viene erogato il <b>ticket</b> viene comunicato al conducente anche quanti potenziali altri conducenti si trovino davanti a lui. Ricordiamo che 
            si tratta di "potenziali" perché non è assicurato che tutti raggiungano il nostro servizio entro <b>TICKETTIME</b>.</li>
            <li>Simile alla precedente ma, invece di inviare il numero di persone che si trovano davanti, si mostra l'informazione direttamente sulla <b>ServiceAccessGUI</b>.</li>
        </ol>
        [SCRIVERE CONSIDERAZIONI FATTE E QUALE SOLUZIONE SI E' SCELTA]
       
        <div class="remark">
            <div class="keypoint">SCRIVERE QUI LA SOLUZIONE ADOTTATA</div>
        </div>
        QUI DEFINIRE LA TEMATICA DEL "CHI VEDE IL CHARGETAKEN,replystorerequest,replyinsertticket"<br>
        Per il peso della <b>ColdRoom</b> mostrato: la <b>ServiceAccessGUI</b> si impegna solamente a mostrare il peso che riceve dalla <b>ColdStorageService</b> 
        ogni qualvolta ci sia un cambiamento del peso. <br>
        Considerando come si è modellata la politica di prenotazione dei <b>ticket</b> nel <b>ColdStorageService</b>
        potrebbe capitare che un conducente che accede alla <b>ServiceAccessGUI</b> veda solo il peso effettivamente presente nella <b>ColdRoom</b>, e 
        non anche quello prenotato. Ciò potrebbe portare a scenari dove un conducente vede attraverso la <b>ServiceAccessGUI</b> che il suo carico ci 
        sta dentro alla <b>ColdRoom</b> ma la sua richiesta <u>storerequest</u> viene rifiutata per spazio insufficiente. Questo è dovuto al fatto che non
        mostrando anche il peso prenotato si potrebbe "illudere" un conducente sul fatto che ci sia posto, ma in realtà tutto qul posto è stato già riservato.<br>
        Per ovviare a questa problematica è sufficiente mostrare il peso complessivo, sommando al peso effettivamente presente all'interno della <b>ColdRoom</b> il 
        peso prenotato. A questo proposito andrebbe modificando l'informazione contenuta dentro <u>coldroomdata</u> che fino ad ora conteneva solo il peso corrente
        della <b>ColdRoom</b>.

        <div class="remark">
            <div class="keypoint">La <b>ServiceAccessGUI</b> deve mostrare il peso della <b>ColdRoom</b> come somma del peso effettivo presente con il peso prenotato.</div>
        </div>
        -come passare la capacità massima alla ServiceAccessGUI?<br>
        -ServiceAccessGUI come observer? Pensando leggerementein futuro(per la statusgui) è bene usare observer.
        
        <h3>ColdStorageService</h3>
        
        <h3>Interazioni</h3>
        <table id="myTable">
            <thead>
                <tr>
                    <th>Messaggio</th>
                    <th>Mittente</th>
                    <th>Destinatario</th>
                    <th>Semantica messaggio</th>
                    <th>Descrizione</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>storerequest</td>
                    <td>ServiceAccessGUI</td>
                    <td>ColdStorageService</td>
                    <td>Request</td>
                    <td>Semantica <u>Request</u> perchè il conducente deve sapere immediatamente se il suo <b>ticket</b> è stato accettato o meno. 
                        Contiene la quantità del peso <b>FW</b> che si vuole scaricare.</td>
                </tr>
                <tr>
                    <td>replystorerequest</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Reply</td>
                    <td>Semantica <u>Reply</u></td>
                </tr>

                <tr>
                    <td>insertticket</td>
                    <td>ServiceAccessGUI</td>
                    <td>ColdStorageService</td>
                    <td>Request</td>
                    <td></td>
                </tr>
                <tr>
                    <td>replyinsertticket</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Reply</td>
                    <td></td>
                </tr>

                <tr>
                    <td>chargetaken</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Dispatch</td>
                    <td></td>
                </tr>

                <tr>
                    <td>coldroomdata</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Dispatch</td>
                    <td></td>
                </tr>
            </tbody>
        </table>

        <h3>Architettura logica</h3>
        <div class="remark">
            Codice QAK per la modellazione del sistema: <a
                href="./sprint2.coldstorageservice/src/ColdStorageService.qak"
                target="_blank">ColdStorageService.qak</a>
        </div>

        Il sistema da noi modellato, presenta la seguente architettura logica:
        <center>
            <div class="piccola">
                <img src="./sprint2/coldstorageservice_sprint2arch.png" alt="architettura logica">
            </div>
        </center>

        <h2>Test plans</h2>
        <table id="myTable1">
            <thead>
                <tr>
                    <th>Test</th>
                    <th>Entità coinvolte</th>
                    <th>Scenario</th>
                    <th>Comportamento atteso</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>
        </table>

        <h2>Project</h2>
        
        <h2>Conclusioni</h2>
        
        <div class="remark">
            Gli output dello sprint2 sono:<br>
            <ul>
                <li>ServiceAccessGUI</li>
                <li>Versione aggiornata ColdStorageService</li>
                <li>MockTransportTrolley</li>
            </ul>
        </div>

        <h4>Goals Sprint 3</h4>
        Si possono definire in seguito i goal relativi allo Sprint3:<br>
        <ol>
            <li>Identificare ed analizzare tutti i problemi relativi ai requisiti che coinvolgono la
                <b>alarm device</b> e il <b>warning device</b>
            </li>
            <li>Integrare al sistema realizzato nello Sprint2 la <b>alarm device</b> e il <b>warning device</b>, che esprimono
            gli <u>Alarm Requirements</u></li>
            <li>Sviluppare il software ed eseguirlo su una scheda Raspberry Pi</li>
            <li>Testare il sistema</li>
        </ol>

        <br /><br />

        <div style="background-color:rgba(86, 56, 253, 0.9); width:60%; text-align:left;color:white">
            By <br>Tassinari Gabriele, email: gabriele.tassinari2@studio.unibo.it<br>
            Baraldi Leonardo, email: leonardo.baraldi@studio.unibo.it<br>
            Koss Krystian, email: krystian.koss@studio.unibo.it<br>
            <div class="foto">
                <img src="./common/gabriele.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./common/Baraldi.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./common/kriss.jpeg" alt="mbot" width="15%" height="15%">
            </div>
            <br>
            GIT repo: https://github.com/4utotune/ColdStorageService/ <br>
        </div>
</body>

</html>