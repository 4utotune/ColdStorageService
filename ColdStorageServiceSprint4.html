<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<script type="text/javascript" src="../css/issStyle.js"></script>
-->

<link rel="stylesheet" type="text/css" href="./common/sprintstyle.css">

<head>
    <title>Sprint4</title>
</head>

<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE<font size="5"></font>
        </h1>
    </div>

    <div class="body">
        <h2>Introduction</h2>
        Lo <b>Sprin43</b> è il naturale proseguo di quanto realizzato nello Sprint2.

        <h2>Requirements</h2>

        <div class="remark">
            <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Descrizione del
                TemaFinale23</a><br>

            <bc>Goals Sprint 4</bc>
            Si possono definire in seguito i goal relativi allo Sprint4:<br>
            <ol>
                <li>Identificare ed analizzare tutti i problemi relativi ai requisiti che coinvolgono la
                    <b>ServiceStatusGUI</b>
                </li>
                <li>Integrare al sistema realizzato nello Sprint3 la <b>ServiceStatusGUI</b></li>
                <li>Realizzare l'interfaccia grafica</li>
                <li>Testare il sistema</li>
            </ol>
        </div>

        <h2>Requirement analysis</h2>

        <h4>Chiarimenti del committente</h4>
        L'interazione con il committente ha permesso di chiarire alcuni aspetti del progetto:
        <ul>
            <li></li>
        </ul>

        <h3>Sistema</h3>
        Questo ultimo Sprint ha come prodotto finale il sistema identificato dallo Sprint0. Nella seguente foto vengono riportati i macro-componenti del sistema complessivo:</b>:
        <center>
            <div class="piccola">
                <img src="./sprint4/sistemasprint4.png" alt="sistema">
            </div>
        </center>
        In questo caso viene introdotta la <b>ServiceStatusGUI</b> che si impegnerà a mostrare lo stato del servizio <b>ColdStorageService</b>.

        <h3>Analisi</h3>
        Dai requisiti espressi nel <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Tema
            Finale</a> e dalle analisi
        già effettuate negli Sprint0, Sprint1, Sprint2 e Sprint3, in questo Sprint occorre analizzare la <b>ServiceStatusGUI</b> che è definita come
        interfaccia utile per mostrare all'addetto della supervisione, detto <b>Service Manager</b>, i dati utili per monitorare il sistema.
        <br><br>
        Ai fini di sorveglianza si ritengono valide mostrare le seguenti informazioni:
        <ul>
            <li>Peso fisico corrente effettivamente presente nella <b>ColdRoom</b></li>
            <li>Peso prenotato ma non ancora presente nella <b>ColdRoom</b></li>
            <li>La posizione del <b>TransportTrolley</b> sulla mappa</li>
            <li>Lo stato del <b>TransportTrolley</b></li>
            <li>Numero di <b>richieste di store rifiutate</b> dall'inizio del sistema</li>
        </ul>


        <h2>Analisi del Problema</h2>


        <h3>Interazioni</h3>
        Data la sua natura, tutte le interazioni hanno come destinatario <b>ServiceStatusGUI</b>. In particolare i seguenti messaggi sono prodotti grazie al 
        <b>pattern Observer</b>, per questo motivo possiedono tutti lo stesso nome "coapUpdate":
        <table id="myTable">
            <thead>
                <tr>
                    <th>Messaggio</th>
                    <th>Mittente</th>
                    <th>Destinatario</th>
                    <th>Semantica messaggio</th>
                    <th>Descrizione</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>coapUpdate</td>
                    <td>transportrolley</td>
                    <td>ServiceStatusGUI</td>
                    <td>Dispatch</td>
                    <td>Informa la <b>ServiceStatusGUI</b> dello stato ...........
                    </td>
                </tr>
            </tbody>
        </table>

        <h3>Architettura logica</h3>
        <div class="remark">
            Codice QAK per la modellazione del sistema: <a href="./sprint3.coldstorageservice/src/SonarLed.qak"
                target="_blank">SonarLed.qak</a>
        </div>

        Il sistema da noi modellato presenta la seguente architettura logica:
        <center>
            <div class="piccola">
                <img src="./sprint3/coldstorageservice_sprint3arch.png" alt="architettura logica">
            </div>
        </center>
        Siccome non compreso nell'immagine, si esplicita il fatto che l'evento alarm giunge anche al
        <b>basicrobot23</b>, il quale alla sua ricezione ferma il DDR Robot.<br>

        <h2>Test plans</h2>
        <table id="myTable1">
            <thead>
                <tr>
                    <th>Test</th>
                    <th>Entità coinvolte</th>
                    <th>Scenario</th>
                    <th>Comportamento atteso</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>testObstacle</td>
                    <td>alarm device</td>
                    <td>Il <b>TransportTrolley</b> sta eseguendo le sue mansioni ed all'improvviso il <b>sonar</b>
                        rileva una distanza minore di <b>DLIMT</b></td>
                    <td>Un evento <b>alarm</b> viene scatenato da <b>alarmdevice</b></td>
                </tr>
                <tr>
                    <td>testConsecutiveObstacleGreaterDLIMT</td>
                    <td>alarm device</td>
                    <td>Il <b>TransportTrolley</b> sta eseguendo le sue mansioni ed all'improvviso il <b>sonar</b>
                        rileva una distanza minore di <b>DLIMT</b> e il <b>transportrolley</b> si ferma.
                        Dopo un tempo pari ad 1/3 di <b>MINT</b> viene effettauta la resume, riattivando il
                        <b>transportrolley</b>. Successivamente dopo <b>MINT</b>
                        millisecondi dal precedente stop il <b>sonar</b> rileva di nuovo una distanza minore di
                        <b>DLIMT</b>.
                    </td>
                    <td>In entrambi gli stop vengono emessi gli eventi <b>alarm</b>.</td>
                </tr>
                <tr>
                    <td>testConsecutiveObstacleLowerDLIMT</td>
                    <td>alarm device</td>
                    <td>Il <b>TransportTrolley</b> sta eseguendo le sue mansioni ed all'improvviso il <b>sonar</b>
                        rileva una distanza minore di <b>DLIMT</b> e il <b>transportrolley</b> si ferma.
                        Dopo un tempo pari ad 1/3 di <b>MINT</b> viene effettauta la resume, riattivando il
                        <b>transportrolley</b>. Successivamente entro <b>MINT</b>
                        millisecondi dal precedente stop il <b>sonar</b> rileva di nuovo una distanza minore di
                        <b>DLIMT</b>, ma immediatamente dopo ritorna a misurare una distanza maggiore di <b>DLIMT</b>.
                    </td>
                    <td>Al primo stop viene emesso l'evento <b>alarm</b>, ma al secondo l'evento <b>alarm</b> non viene
                        scatenato.</td>
                </tr>
            </tbody>
        </table>

        <h2>Project</h2>
        Siccome nell'analisi del problema si è utilizzato un simulatore del <b>sonar</b> per creare il QAK, il passo
        successivo è quello di integrarne uno fisico. Per fare ciò si adotta un broker gratuito e a disposizione di
        tutti come <u>tcp://mqtt.eclipseprojects.io</u> che permette l'invio e la ricezione di eventi tra dispositivi
        fisicamente non collegati ma connessi alla rete internet.<br>
        Per comunicare dati utilizzando <b>MQTT</b> bisogna definire un topic che definisce il canale di utilizzo, utile
        per distinguere categorie di eventi che vogliamo raggruppare.
        Nel nostro caso si è adottato <b>unibo/sonar/events</b> come topic per comunicare i dati
        dal <b>Raspberry</b> al Servizio. Prima di essere considerati da <b>ColdStorageService</b>, vengono filtrati da:
        <ul>
            <li><b>SonarMQTTReceiver</b>: si impegna a ricevere i dati "grezzi" del <b>sonar</b> tramite MQTT e poi
                propaga l'evento all'interno del contesto ctx_coldstorage</li>
            <li><b>DataCleaner</b>: pulisce i valori scartando le misurazioni che non sono comprese in un range che va
                da 2 a 150 cm</li>
            <li><b>DistanceFilter</b>: riceve i dati puliti dal <b>DataCleaner</b> e invia un evento <b>obstacle</b> o
                <b>obstaclefree</b> qualora le misurazioni rispettivamente siano inferiori di <b>DLIMT</b>
                oppure maggiori
            </li>
        </ul>
        Per finire la catena: gli eventi <b>obstacle</b> e <b>obstaclefree</b> sono captabili da <b>alarm device</b> e,
        qualora le condizioni riguardanti il tempo <b>MINT</b> tra uno stop e l'altro siano soddisfatte, emette un
        evento alarm che verrà ricevuto sia da <b>basicrobot23</b> sia dal <b>Transport Trolley</b>.
        <br><br>
        Anche per comunicare con il <b>led</b> si utilizza MQTT, mandando un messaggio con l'ausilio dell'attore
        <b>LedMQTTSender</b> ed utilizzando <b>unibo/led/events</b> come topic.
        <br><br>
        Per la fase di prototipazione il <b>sonar</b> e <b>led</b> saranno collegati ad un <b>Raspberry</b> tramite dei
        cavetti jumper femmina-femmina.
        <br>
        Il software lato <b>Raspberry</b> sarà organizzato nella seguente maniera:
        <ul>
            <li>Un programma python che si occupa di utilizzare il <b>sonar</b> per estrapolare le distanze misurate
            </li>
            <li>Un programma python che cattura tali dati da standard input e li inoltra al broker nel corretto topic
            </li>
            <li>Un programma python che riceve dal broker i comandi e li inoltra su standard input</li>
            <li>Un programma python che legge da standard input e comanda il led</li>

        </ul>
        Per definizione i programmi devono essere eseguiti in pipe, ad es. (per il sonar): <u>python sonar.py | python
            controllerMQTT.py</u>
        <br><br>
        I file che definiscono il software necessario per il <b>Raspberry</b> sono: <a
            href="./sprint3/sonar.py">sonar.py</a>, <a href="./sprint3/ControllerMqtt.py">controllerMQTT.py</a>,
        <a href="./sprint3/LedDevice.py">LedDevice.py</a>, <a href="./sprint3/mqttReceiver.py">mqttReceiver.py</a>
        <br><br>
        La scelta di Python è motivata dal fatto che è un linguaggio ideale per la prototipazione: rapido,
        con molte librerie di supporto e ben documentato.
        Successivamente se si desiderano performace migliori si può pensare di ottimizzare scrivendo codice di più basso
        livello.
        <br><br>
        I pin del <b>Raspberry</b> coinvolti sono:
        <ul>
            <li><b>GPIO 4</b>: pin TRIG sonar</li>
            <li><b>GPIO 27</b>: pin ECHO sonar</li>
            <li><b>GPIO 25</b>: pin led</li>
        </ul>

        <h2>Conclusioni</h2>

        <div class="remark">
            Gli output dello sprint3 sono:<br>
            <ul>
                <li>Warning Device e relativi attori e file python</li>
                <li>Alarm Device e relativi attori e file python</li>
            </ul>
        </div>

        

        <br/><br/>

        <div style="background-color:rgba(86, 56, 253, 0.9); width:60%; text-align:left;color:white">
            By <br>Tassinari Gabriele, email: gabriele.tassinari2@studio.unibo.it<br>
            Baraldi Leonardo, email: leonardo.baraldi@studio.unibo.it<br>
            Koss Krystian, email: krystian.koss@studio.unibo.it<br>
            <div class="foto">
                <img src="./common/gabriele.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./common/Baraldi.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./common/kriss.jpeg" alt="mbot" width="15%" height="15%">
            </div>
            <br>
            GIT repo: https://github.com/4utotune/ColdStorageService/ <br>
        </div>
</body>

</html>