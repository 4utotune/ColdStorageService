System coldstorageservice_sprint3


//mqttBroker "mqtt.eclipseprojects.io" : 1883 eventTopic "unibo/sonar/events"
/*
 * To do:
 * resume
 * il sonar funziona tuttavia se con il sonar simulator
 * imposto 80 il basicrobot non funziona 
 */

 
// MESSAGES

// BasicRobot
Request 	engage				: 	engage(OWNER,STEPTIME)
Reply 		engagedone			:	engagedone(ARG)
Reply 		engagerefused		: 	engagerefused(ARG)

Dispatch 	disengage			: 	disengage(ARG)

Dispatch 	cmd					:	cmd(MOVE)
Dispatch 	end					: 	end(ARG)

Request 	step				: 	step(TIME)
Reply 		stepdone			: 	stepdone(V)
Reply 		stepfailed			: 	stepfailed(DURATION, CAUSE)

Request 	doplan				: 	doplan(PATH,OWNER,STEPTIME)
Reply 		doplandone			: 	doplandone(ARG)
Reply 		doplanfailed		:	doplanfailed(ARG)

Request 	moverobot			:	moverobot(TARGETX, TARGETY)
Reply 		moverobotdone		: 	moverobotok(ARG)
Reply 		moverobotfailed		: 	moverobotfailed(PLANDONE,PLANTODO)

Dispatch 	setrobotstate		: 	setpos(X,Y,D)
Dispatch 	setdirection		: 	dir(D) // up, down, left, right

Request 	getrobotstate		: 	getrobotstate(ARG)
Reply 		robotstate			: 	robotstate(POS,DIR)

// transport trolley -> coldstorageservice
Dispatch	chargetaken			: 	chargetaken(_)
Request 	chargedeposited		: 	chargedeposited(_)

// coldstorageservice -> transporttrolley
Reply 		more				:	more(_)
Reply 		gohome				: 	gohome(_)
Dispatch 	gotoindoor			: 	gotoindoor(_)

// PER MOCK:
Request 	storerequest		: 	storerequest(FW)
Reply		storeaccepted		:	storeaccepted(TICKET)
Reply		storerejected		: 	storerejected(_)

Request		insertticket		: 	insertticket(TICKET)
Reply		ticketaccepted		: 	ticketaccepted(_)
Reply		ticketrejected		: 	ticketrejected(_)

Dispatch 	mock_store_request 	: 	mock_store_request(FW)
Dispatch 	mock_ticket_input 	:	mock_ticket_input(TICKET)
Dispatch 	test_gotticket 		: 	test_gotticket(TICKET)
Dispatch	next_test			:	next_test(_)

//Observer TT->Led
Dispatch	coapUpdate			:	coapUpdate(SOURCE,ARG)

//Sonar DistanceFilter e SonarCleaner
Event sonardata : distance(D)   //emitted  by distancefilter
Event obstacle  : obstacle(D)   //emitted as stream by distancefilter
Event obstaclefree	:	obstaclefree(D)	//emitted as stream by distancefilter
 
//Fermare il BasicRobot
Event alarm           : alarm(X)
//Riprendere il TT 
Event resume		  : resume(X)

//comunicare al led lo stato
Event ledoff		  : ledoff(_)
Event ledon 		  : ledon(_)
Event ledblink		  : ledblink(_)

// Context ctx_mockgui		ip [host="localhost" port=11800]
Context ctx_basicrobot 	ip [host="127.0.0.1" port=8020]  
Context ctx_coldstorage ip [host="localhost" port=11802]
// Context ctx_trolley 	ip [host="localhost" port=11801] 

//CodedQActor sonar  context ctx_coldstorage className "sonarSimulator"           //IN LOCALE
  
CodedQActor sonar  context ctx_coldstorage className "rx.SonarMQTTReceiver"
CodedQActor datacleaner    context ctx_coldstorage className "rx.DataCleaner"
CodedQActor distancefilter context ctx_coldstorage className "rx.DistanceFilter"
CodedQActor ledMQTTSender  context ctx_coldstorage className "rx.ledMQTTSender"

ExternalQActor basicrobot context ctx_basicrobot




QActor test_suite context ctx_coldstorage {
	[# var Current: Int = 1 #]
	
	State init initial {
		println("$name | Init") color yellow
		delay 2000
	}
	Goto test1
	
	State idle {
		[# Current++ #]
	} 
	Transition t 	whenMsg next_test and [# Current == 1 #] -> test1
					whenMsg next_test and [# Current == 2 #] -> test2
					whenMsg next_test and [# Current == 3 #] -> test3
					whenMsg next_test and [# Current == 4 #] -> test4
					whenMsg next_test and [# Current == 5 #] -> test5
					whenMsg next_test and [# Current == 6 #] -> test6
					whenMsg next_test -> reset 
					
	State reset {
		[# Current = 0 #]
		println("$name | New test loop") color yellow
		forward test_suite -m next_test: next_test(_)
	}
	Goto idle
	
	State test1 {
		println("$name | Test 1 - normal request") color yellow
		forward accessguimock -m mock_store_request: mock_store_request(30)
		delay 2000
	}
	Transition t0 	whenMsg 	test_gotticket 	-> test1_b
	
	State test1_b {
		onMsg(test_gotticket: test_gotticket(TICKET)) {
			[# val Ticket = payloadArg(0) #]
			forward accessguimock -m mock_ticket_input: mock_ticket_input($Ticket) 
		}
	}
	Goto idle
	
	State test2 {
		println("$name | Test 2 - Request while Service is serving another Truck") color yellow
	}
	Goto test2_a
	
	State test2_a {
		forward accessguimock -m mock_store_request: mock_store_request(10)
	}
	Transition firstticket whenMsg test_gotticket 	-> test2_b
	
	State test2_b {
		onMsg(test_gotticket: test_gotticket(TICKET)) {
			forward accessguimock -m mock_ticket_input : mock_ticket_input($payloadArg(0)) 
			delay 500
			forward accessguimock -m mock_store_request: mock_store_request(10)
		}
	}
	Transition secondticket whenMsg test_gotticket 	-> test2_c
	
	State test2_c {
		onMsg(test_gotticket: test_gotticket(TICKET)) {
			delay 5000			
			forward accessguimock -m mock_ticket_input : mock_ticket_input($payloadArg(0)) 
		}
	}
	Goto idle
	
	State test3 {
		println("$name | Test 3 - Inputing non-existent ticket (should fail)") color yellow
		forward accessguimock -m mock_ticket_input: mock_ticket_input(abcdefghi) 
		delay 2000
		forward test_suite -m next_test: next_test(_)
		
	}
	Goto idle 
	
	State test4 {
		println("$name | Test 4 - Requesting too big of a store (should fail)") color yellow
		forward accessguimock -m mock_store_request: mock_store_request(1000)
		delay 2000
		forward test_suite -m next_test: next_test(_)
	}
	Goto idle
	
	State test5 {
		println("$name | Test 5 - Inputing ticket too late (should fail)") color yellow
		forward accessguimock -m mock_store_request: mock_store_request(30)
	}
	Transition t1 	whenMsg 	test_gotticket 	-> test5_b
	
	State test5_b {
		onMsg(test_gotticket: test_gotticket(TICKET)) {
			delay 20000
			forward accessguimock -m mock_ticket_input: mock_ticket_input($payloadArg(0)) 
			delay 2000
			forward test_suite -m next_test: next_test(_)
		}
	}
	Goto idle
	
	State test6 {
		println("$name | Test 6 - Requesting store exceeding DDR capacity") color yellow
		forward accessguimock -m mock_store_request: mock_store_request(60)
		delay 2000
		forward test_suite -m next_test: next_test(_)
	}
	Goto idle
}


QActor accessguimock context ctx_coldstorage { 
	[#
		var currentWeight: Float = 0.0f	
	#]
	State init initial {
		println("$name | Init") color cyan
		[# currentWeight = 0.0f #]
	}
	Goto idle
	
	State idle{
		
	}
	Transition t0 	whenMsg 	mock_store_request 	-> handle_mock_store_request
					whenMsg 	mock_ticket_input	-> handle_mock_ticket_input
					whenMsg		chargetaken 		-> handle_charge_taken	
	
	State handle_mock_store_request {
		onMsg ( mock_store_request : mock_store_request(FW)){
			println("$name | Sending store request") color cyan
			request coldstorageservice -m storerequest: storerequest($payloadArg(0))
		}
	}
	Transition 	t	whenReply 	storeaccepted 	-> handle_store_accepted
					whenReply 	storerejected 	-> handle_store_rejected
	
	State handle_store_accepted {
		onMsg(storeaccepted: storeaccepted(TICKET)) {
			[# val TICKET = payloadArg(0) #]
			println("$name | Store Accepted. Received ticket [ $TICKET ]") color cyan
			forward test_suite -m test_gotticket: test_gotticket($TICKET)
		}
	}
	Goto idle
	
	State handle_store_rejected {
		onMsg(storerejected: storerejected(REASON)) {
			println("$name | Store Rejected: ${payloadArg(0)}") color cyan
			// TODO show error message
		}
		
	}
	Goto idle
	
	State handle_mock_ticket_input {
		onMsg ( mock_ticket_input : mock_ticket_input(TICKET)){
			[# val TICKET = payloadArg(0) #]
			println("$name | Sending ticket [ $TICKET ]") color cyan
			request coldstorageservice -m insertticket: insertticket($TICKET)
		}
	}
	Transition 	t	whenReply 	ticketaccepted 	-> handle_ticket_accepted
					whenReply 	ticketrejected 	-> handle_ticket_rejected						
	
		
	State handle_ticket_accepted {
		println("$name | Ticket Accepted") color cyan
	}
	Goto idle
	
	State handle_ticket_rejected {
		onMsg(ticketrejected: ticketrejected(REASON)) {
			println("$name | Ticket Rejected: ${payloadArg(0)}") color cyan
		}
	}
	Goto idle
	
	State handle_charge_taken {
		// println("$name | Charge Taken") color cyan
	}
	Goto idle
}


QActor coldstorageservice context ctx_coldstorage {
	[#	
		val MaxWeightDDR = 50.0f
		val MaxWeightcoldroom = 100.0f
		val TicketTimeout = 20000
		val TicketFormat = "yyyyMMddHHmmss"; // yyyy.MM.dd.HH.mm.ss
		
		var ticketManager = coldstorageservice.TicketManager(TicketTimeout, TicketFormat);
		
		var CurrentWeight = 0.0f
		var ReservedWeight = 0.0f
		var RejectedRequests = 0 
	#]
	State s0 initial {
		[# 
			ticketManager = coldstorageservice.TicketManager(TicketTimeout, TicketFormat);
			CurrentWeight = 0.0f 
			ReservedWeight = 0.0f
			RejectedRequests = 0
		#]
		println("$name | init") color green
	}
	Goto idle
	
	State idle {
		println("$name | Idle. Current: $CurrentWeight, Reserved: $ReservedWeight") color green
	}
	Transition t0 whenRequest storerequest		-> handle_store
				  whenRequest insertticket		-> handle_ticket
				  whenRequest chargedeposited	-> handle_deposited
				  whenMsg	  chargetaken		-> handle_charge_taken
					
	State handle_store {
		onMsg(storerequest: storerequest(FW)) {
			println("$name | Received store request for ${payloadArg(0)} kg") color green
			[# val FW = payloadArg(0).toFloat() #]
			
			if [# (FW > MaxWeightDDR) #] {
				[# RejectedRequests++ #]
				replyTo storerequest with storerejected: storerejected(tooheavy)
			} else {
				if [# ((CurrentWeight + ReservedWeight + FW) > MaxWeightcoldroom) #] {
					[# RejectedRequests++ #]
					replyTo storerequest with storerejected: storerejected(full)
				} else {
					[#
						val TICKET = ticketManager.newTicket(FW)
					  	ReservedWeight += FW
					  	val Timestamp = TICKET.timestamp
					#]
					replyTo storerequest with storeaccepted: storeaccepted($Timestamp)
				}	
			}
		}
	}
	Goto idle
	
	State handle_ticket {
		onMsg(insertticket: insertticket(TICKET)) {
			[# 
				val Received = payloadArg(0).toString()
				val TICKET = ticketManager.getTicket(Received)
			#]
			if [# (TICKET != null && TICKET.isValid) #]{
				if [# (ticketManager.isWaiting) #] {
					// reject ticket if one is already waiting
					replyTo insertticket with ticketrejected: ticketrejected(queuefull)
				} else {
					if [# (!ticketManager.isWorking) #] {
						println("$name | Approved ticket [ $Received ]. Requesting charge") color green
						forward transporttrolley -m gotoindoor: gotoindoor(_)
					} else {
						println("$name | Approved ticket [ $Received ]. Currenty working on [ ${ticketManager.working} ]. Please wait") color green
					}
						
					[#  ticketManager.setWaiting(Received) #]
					replyTo insertticket with ticketaccepted: ticketaccepted(_)
				}
			} else {
				if [#(TICKET != null)#] {
					[#
						ticketManager.remove(TICKET)
						ReservedWeight -= TICKET.weight
					#]
					println("$name | Rejected ticket [ $Received ] - timedout") color green
					replyTo insertticket with ticketrejected: ticketrejected(timedout)
				} else {
					println("$name | Rejected ticket [ $Received ] - doesn't exist") color green
					replyTo insertticket with ticketrejected: ticketrejected(invalid)	
				}				
			}
		}
	}
	Goto idle
	
	State handle_charge_taken {
		[# 			
			val Timestamp = ticketManager.waitingNowWorking()
		#]
		println("$name | Charge taken for ticket [ $Timestamp ]") color green
		forward accessguimock -m chargetaken: chargetaken(_)
	}
	Goto idle
	
	State handle_deposited {
		onMsg(chargedeposited: chargedeposited(_)) {
			[#
				if (ticketManager.isWorking) {
					CurrentWeight += ticketManager.workingTicket().weight
					ReservedWeight -= ticketManager.workingTicket().weight
				}
				ticketManager.stopWorking()
			#]
			println("$name | Deposit confirmation received") color green
			if [# (ticketManager.isWaiting) #] {
				println("$name | Next ticket: [ ${ticketManager.waiting} ]") color green
				replyTo chargedeposited with more: more(_)
			} else {
				replyTo chargedeposited with gohome: gohome(_)
			}
		}
	}
	Goto idle
}
/*
 *QActor alarmino context ctx_coldstorage{
    State init initial {
        println("$name | Init") color blue

    }
    Goto idle

    State idle { 
    	delay 7000
        emit alarm : alarm(_)
        println("[alarmino] fermi tutti o sparo!") color black
    } 
}*/

//sonar
QActor alarmdevice context ctx_coldstorage {
	//il prefixed amount of time lo consideriamo 10sec
	[# var LastStop = 0L
	   var MINT = 10000L
	   var Delta = 0L
	#]
	State init initial { 
		[# subscribeToLocalActor("distancefilter").subscribeToLocalActor("datacleaner").subscribeToLocalActor("sonar") #]
		println ("$name | init") color black
	}
	Goto work
	
	State work {
		println("$name | attendo...") color black
	}
	Transition t0 whenEvent obstacle  -> handleobstacle
	
	State handleobstacle{ 
		onMsg( obstacle : obstacle(D)){
			emit alarm : alarm(_)			
			println("$name handleobstacle ALARM ${payloadArg(0)}") color black
			updateResource [# "$name(ON)"#]	
			[# LastStop = System.currentTimeMillis()#]	
		}	
	}
	Transition t0 whenEvent obstaclefree -> handleobstaclefree	               
	
	State handleobstaclefree {
		onMsg( obstaclefree : obstaclefree(D)){			
			println("$name handleobstacle ALARM ${payloadArg(0)}") color black
			emit resume : resume(_) //resume TT
			println("$name aspetto DLMIT prima di poter gestire un successivo stop")
			[# Delta=MINT-(System.currentTimeMillis()-LastStop) 
			   delay(Delta)			
			#]
			println("$name sono di nuovo pronto per poter gestire uno stop")
		}
	}Goto work
}


//Led
QActor warningdevice context ctx_coldstorage {
	[# 
		var state = 0
		var stato1 = "0"
	#]
	State init initial {
		println ("$name | init") color blue
		observeResource transporttrolley
		println("$name | LED IS OFF")
	}
	Goto work
	
	State work {
		println("$name | attendo update") color blue
	}
	Transition t0 whenMsg coapUpdate -> doObserve
	
	State doObserve {
		discardMsg Off
		onMsg ( coapUpdate : coapUpdate(transporttrolley, ARG)){
			[# var stato1 = payloadArg(1) #]
			if [# (stato1 == "transporttrolley(OFF)") #] {
				println("$name | led off | ricevuto dal TT") color blue
				[# state = 0 #]
				emit ledoff : ledoff(_)
			} else {
			if [# (stato1 == "transporttrolley(ON)") #] {
				println("$name | led ON | ricevuto dal TT") color blue
				[# state = 1 #]
				emit ledon : ledon(_)
			} else {
			if [# (stato1 == "transporttrolley(BLINK)") #] {
				println("$name | led BLINK | ricevuto dal TT") color blue
				[# state = 2 #]
				emit ledblink : ledblink(_)
			} 
			else {
				println ("$name | $stato1 | sconosciuto | ricevuto dal TT") color blue
			}
			}
			}	 
		}
		onMsg( coapUpdate : coapUpdate(alarmdevice, ARG)){
			[# var stato2 = payloadArg(1) #]
			if [# (stato2 == "ON") #] {
				println("$name | led on | ricevuto dal sonar") color blue
				[# state = 1 #]
			} else {
				println ("$name | sconosciuto | ricevuto dal sonar") color blue
			}
		}
	}
	Goto work
	
}


QActor transporttrolley context ctx_coldstorage {// ctx_trolley {
	[# var allarme: Int = 0 #]
	State s0 initial {
		println("$name | init e engage basicrobot") color magenta
		//delegate "obstacle" to sonarobstacle
		// Il transporttrolley richiede l'impegno del basicrobot
		request basicrobot -m engage : engage(transporttrolley,330)
	}
	Transition 	t0	whenReply engagedone -> engaged
					whenReply engagerefused -> quit
	
	State engaged {
		println("$name | basicrobot engaged") color magenta
		updateResource [# "$name(OFF)"#]
	}
	Goto idle
	
	State idle{
		[# allarme = 1 #]
	}
	Transition t0 whenMsg gotoindoor -> moveToIndoor
				  whenEvent alarm -> sonarobstacle
	
	State moveToIndoor {
		[# allarme = 2 #]
		updateResource [# "$name(BLINK)"#]
		//discardMsg On
		println("$name | vado all'INDOOR") color magenta
		request basicrobot -m moverobot : moverobot (0,4)
	}
	Transition t0 whenReply moverobotdone -> loadTheCharge
				  //whenReply moverobotfailed -> pathfailed
				  whenEvent alarm -> sonarobstacle
	
	State loadTheCharge{
		//discardMsg On
		[# allarme = 3 #]
		updateResource [# "$name(ON)"#]
		println("$name | sto caricando il carico presso l'INDOOR") color magenta
		// simulo azione di carico
		//delay 1000
		forward coldstorageservice -m chargetaken : chargetaken(_)

		updateResource [# "$name(BLINK)"#]
		//discardMsg On
		println("$name | vado verso la cold room") color magenta
		request basicrobot -m moverobot: moverobot (4,3) 
	}
	Transition t0 whenReply moverobotdone -> storethecharge
			      //whenReply moverobotfailed -> pathfailed1
			      whenEvent alarm -> sonarobstacle
	
	State storethecharge {
		[# allarme = 4 #]
		updateResource [# "$name(ON)"#]
		//discardMsg On
		println("$name | scarico il carico presso la Cold Room") color magenta
		// simulo azione di scarico
		delay 1000
		request coldstorageservice -m chargedeposited : chargedeposited(_)
	}
	Transition t0 whenReply more -> moveToIndoor
				  whenReply gohome -> movetohome
				  whenEvent alarm -> sonarobstacle
	
	State movetohome{
		[# allarme = 5 #]
		updateResource [# "$name(BLINK)"#]
		//discardMsg On 
		println("$name | vado alla posizione HOME") color magenta
		request basicrobot -m moverobot : moverobot (0,0)
	}
	Transition t0 whenReply moverobotdone -> trolleyathome
				  //whenReply moverobotfailed -> pathfailed2
				  whenEvent alarm -> sonarobstacle
	
	State trolleyathome {
		updateResource [# "$name(OFF)"#]
		//discardMsg On
		println("$name | trolley at HOME") color magenta
		forward basicrobot -m setdirection : dir(down)
		delay 500
		
		forward test_suite -m next_test: next_test(_)
	}
	Goto idle
	
	State pathfailed {
		println("$name | Errore | PATH FAILED | RITENTO") color magenta
	}Goto moveToIndoor
	
	/*State pathfailed1 {
		println("$name | Errore | PATH FAILED | RITENTO") color magenta
	}Goto movetocoldroom*/
	
	State pathfailed2 {
		println("$name | Errore | PATH FAILED | RITENTO") color magenta
	}Goto movetohome
	
	State sonarobstacle {
		println("$name | Sono fermo per ostacolo sonar") color magenta
	}
	Transition t0 whenEvent resume and [# allarme == 1 #] -> idle
				  whenEvent resume and [# allarme == 2 #] -> moveToIndoor
				  whenEvent resume and [# allarme == 3 #] -> loadTheCharge
				  whenEvent resume and [# allarme == 4 #] -> storethecharge
				  whenEvent resume and [# allarme == 5 #] -> movetohome
	
	State quit {
		updateResource [# "$name(OFF)"#]
		forward basicrobot -m disengage : disengage(transporttrolley)
		[# System.exit(0) #]
	}
}
