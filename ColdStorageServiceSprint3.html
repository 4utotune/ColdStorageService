<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<script type="text/javascript" src="../css/issStyle.js"></script>
-->

<link rel="stylesheet" type="text/css" href="./common/sprintstyle.css">

<head>
    <title>Sprint3</title>
</head>

<body>

    <div id="top">

        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE<font size="5"></font>
        </h1>

    </div>

    <div class="body">

        <h2>Introduction</h2>
        Lo <b>Sprint3</b> è il naturale proseguo di quanto realizzato nello Sprint2. 
        

        <h2>Requirements</h2>

        <div class="remark">
            <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Descrizione del
                TemaFinale23</a><br>

            <bc>Goals Sprint 3</bc>
            <ol>
                <li>Identificare ed analizzare tutti i problemi relativi ai requisiti che coinvolgono la
                    <b>alarm device</b> e il <b>warning device</b>
                </li>
                <li>Integrare al sistema realizzato nello Sprint2 la <b>alarm device</b> e il <b>warning device</b>, che esprimono
                gli <u>Alarm Requirements</u></li>
                <li>Sviluppare il software ed eseguirlo su una scheda Raspberry Pi</li>
                <li>Testare il sistema</li>
            </ol>
        </div>

        <h2>Requirement analysis</h2>

        <h4>Chiarimenti del committente</h4>
        L'interazione con il committente ha permesso di chiarire alcuni aspetti del progetto:
        <ul>
            <li></li>
        </ul>

        <h4>Chiarimenti con il committente</h4>
        <ul>
            <li></li>
        </ul>

        <h3>Sistema</h3>
        Il macro-componente identificato che si va ad aggiungere al prodotto degli sprint precedenti è <b>warning ed alarm devices</b>:
        <center>
            <div class="piccola">
                <img src="./sprint3/sysSprint3.png" alt="sistema">
            </div>
        </center>
        In questo caso si andrà a lavorare con componenti fisici come:
        <ul>
            <li>un <b>Led</b></li>
            <li>un <b>Sonar</b></li>
            <li>una scheda <b>Raspberry Pi</b> che identificherà il nodo computazionale dei due devices</li>
            <li>cavetti jumper femmina-femmina per permettere i collegamenti tra il <b>Sonar</b>,<b>Led</b> e <b>Raspberry Pi</b></li>
        </ul>

        <h3>Analisi</h3>
        Dai requisiti espressi nel <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Tema
            Finale</a> e dalle analisi
        già effettuate negli Sprint0, Sprint1 e Sprint2, in questo Sprint occorre analizzare le entità:
        <ul>
            <li><b>alarm device</b>, che si occupa di notificare quando una soglia <b>DLIMT</b> viene violata, al fine di fermare il <b>Transport Trolley</b></li>
            <li><b>warning device</b>, che si occupa di mostrare lo stato del <b>Transport Trolley</b> tramite un <b>Led</b></li>
        </ul>
        Entrambi dovranno eseguire all'interno di una scheda Raspberry Pi.<br>
        Inoltre questi rappresentano gli <b>Alarm Requirements</b> ceh dovranno essere sempre soddisfatti per fare in modo che il <b>Transport trolley</b> si comporti
        in linea con i requisiti forniti dal committente.
        <br>
        <h4>alarm device</h4>
        L'<b>alarm device</b> è un componenete costituito da un <b>Sonar</b> che è in grado di misurare la distanza tra esso ed un ostacolo presente di fronte al medesimo.
        Quando il <b>Sonar</b> rileva una distanza minore di una soglia <b>DLIMT</b> il <b>Transport Trolley</b> deve essere fermato, fino a che non viene rilevata 
        una distanza maggiore sempre di <b>DLIMT</b>.<br>
        Nota importante è che il <b>Transport Trolley</b> non può essere fermato due volte consecutive entro un lasso di tempo pari a <b>MINT</b> millisecondi, bensì dovrebbe
        intercorrere un tempo <b>MINT</b> millisecondi tra uno stop e quello successivo.


        <h4>warning device</h4>
        Il <b>warning device</b> è un componenete costituito da un <b>Led</b> che comunica lo stato del <b>Transport trolley</b>.
        Il <b>Led</b> può rappresentare 3 stati diversi:
        <ul>
            <li><b>Transport Trolley in HOME</b>: il <b>Led</b> è spento</li>
            <li><b>Transport Trolley in movimento</b>: il <b>Led</b> lampeggia con un intervallo costante</li>
            <li><b>Transport Trolley è fermo</b>: il <b>Led</b> è acceso</li>
        </ul>


        <h2>Analisi del Problema</h2>
        Innanzitutto gli <b>Alarm Requirements</b> devono essere sempre soddisfatti:
        <div class="remark">
            <div class="keypoint">Gli <b>Alarm Requirements</b> devono essere sempre soddisfatti per permettere il corretto funzionamento del <b>Transport trolley</b></div>
        </div>

        Come prodotto finale di questo Sprint di dovrà ottenere del software eseguibile su una scheda rapberry Pi:
        <div class="remark">
            <div class="keypoint">I componenti <b>warning device</b> e <b>alarm device</b> devono essere in esecuzione all'interno di un Raspberry Pi</div>
        </div>

        Il <b>Transport trolley</b> dovrà fermarsi quando il <b>Sonar</b> misura una distanza minore di una soglia <b>DLIMT</b> ed risbloccarlo quando tale soglia viene
        superata per eccesso.
        <div class="remark">
            <div class="keypoint">Il <b>Transport Trolley</b> deve fermarsi quando il <b>Sonar</b> rileva una misura minore di una soglia <b>DLIMT</b></div>
        </div>
        Mentre quando il <b>Transport trolley</b> verrà rimesso in movimento, è utile che riprenda dal punto dove si era fermato evitando così di corrompere i servizi
        ai <b>Fridge Truck</b>. Altrimenti, se ogni volta che si ferma il <b>Transport Trolley</b> non si ha cura di mantenere un checkpoint, quando questo verrà rimesso
        in movimento non avrebbe memoria di cosa stava facendo prima ed il servizio che aveva laciato in sospeso non potrà essere mai soddifatto, lasciando il sistema in uno 
        stato inconsistente.
        <div class="remark">
            <div class="keypoint">Una volta che la soglia misurata dal <b>sonar</b> viene superata per 
            eccesso, dopo che il <b>Transport Trolley</b> è stato fermato per via della soglia violata, il <b>Transport Trolley</b> tornerà a svolgere il compito su 
            cui stava lavorando quando è stato fermato</div>
        </div>
        Il <b>Transport Trolley</b> una volta fermato può subire un altro stop solo dopo <b>MINT</b> millisecondi, per questo motivo si possono presentare due scenari:
        <ol>
            <li>Arriva uno stop <u>dopo</u> <b>MINT</b> millisecondi ed in quel momento il <b>Transport trolley</b> è in movimento</li>
            <li>Arriva uno stop <u>dopo</u> <b>MINT</b> millisecondi ed in quel momento il <b>Transport trolley</b> è ancora fermo dallo stop precedente</li>
            <li>Arriva uno stop <u>prima</u> <b>MINT</b> millisecondi ed in quel momento il <b>Transport trolley</b> è in movimento</li>
            <li>Arriva uno stop <u>prima</u> <b>MINT</b> millisecondi ed in quel momento il <b>Transport trolley</b> è ancora fermo dallo stop precedente</li>
        </ol>
        Lo scenario <b>1</b> è quello che non introduce alcun problema perché gli eventi succedono in momenti che soddisfano tutti i requisiti.<br>
        Gli scnenari <b>3</b> e <b>4</b> presentano uno stop prima del tempo concesso. Andrebbe valutato come si vuole agire:
        <ul>
            <li>se ignorare le richieste che arrivano prima del dovuto</li>
            <li>se prendere in considerazione una coda di eventi che sono arrivati ma non ancora considerabili perché gli <b>Alarm Requirements</b> non lo permettono</li>
        </ul>
        Valutando prima lo scenario <b>4</b>: pensando da un punto di vista di user experience si valuta valida la soluzione di ignorare le richieste di stop che arrivano prima del dovuto solo se queste sono già
        state seguite da un resume prima ancora che il tempo <b>MINT</b> sia trascorso. Questo perché non ci sarebbe bisogno di fermare il <b>Transport Trolley</b>
        se al momento corrente il <b>Sonar</b> rileva una distanza maggiore di <b>DLIMT</b>, anche se non si è fermato allo stop precedente, siccome nel momento in cui 
        il <b>Transport Trolley</b> si sarebbe dovuto fermare in realtà era già fermo.<br>
        Se invece di quanto riportato sopra, arriva uno stop prima di <b>MINT</b> millisecondi ed il <b>Transport trolley</b> è in movimento(scenario <b>3</b>) allora
        bisogna aspettare, mettendo in coda l'evento, l'intervallo minimo prima di fermare il <b>Transport Trolley</b>. Se entro a <b>MINT</b> oltre allo stop, arriva 
        anche la resume allora non si dovrà fermare.<br>
        Infine per lo scenario <b>2</b>: se il <b>Transport Trolley</b> riceve uno stop dopo <b>MINT</b> millisecondi ed è ancora fermo dallo stop precedente
        allora si dovrà semplicemente ignorare l'evento in quanto il <b>Transport Trolley</b> è già fermo.
        In seguito viene riportato il riassunto con un grafo degli eventi <u>numerato per scenario</u>:

        <center>
            <div class="piccola">
                <img src="./sprint3/diagrammaeventi.png" alt="architettura logica">
            </div>
        </center>

        <div class="remark">
            <div class="keypoint">Gestire gli <b>stop/resume</b> del <b>Transport Trolley</b> secondo la politica esplicitata nel grafo degli eventi sopra riportato</div>
        </div>

        Sorge un problema quando introduciamo il concetto di <u>fermare il <b>Transport Trolley</b> e riattivarlo</u>, siccome dobbiamo fermarlo all'istante e alla resume
        dovrebbe tornare a fare quello che stava facendo. Ricordiamo che per effettuare gli spostamenti del <b>Transport Trolley</b> si utilizza il <b>planner</b>
        che adotta una semantica request-reply al <b>basicrobot23</b> e l'unico modo per interromperne l'esecuzione è tramite il comando <b>alarm</b>. Mentre per fare in modo
        che il <b>Transport Trolley</b> riprenda quello che stava facendo bisogna avere cura di salvarsi l'ultima operazione non portata a termine e rieffettuare tale richiesta.
        Ciò è possibile perchè il <b>Transport Trolley</b> comunica con <b>basicrobot23</b> tramite il solo comando <b>moverobot(coordinate)</b>, questa cosa ci agevola la 
        risoluzione della casisitica siccome quando il <b>Transport Trolley</b> viene fermato da un <b>alarm</b> per riprendere ciò che stava facendo è sufficiente ripetere
        lo stesso comando <b>moverobot(coordinate)</b> che non era andato a buon fine per via dell'evento straordinario. Questo è dovuto dal fatto che indipendentemente dalla
        posizione del <b>Transport Trolley</b>, comunicando a questo ultimo <b>moverobot(coordinate)</b> il risultato sarà il medesimo, ovvero raggiungere tale posizione richiesta.
        Questo ci permette di non tenere traccia degli <b>step</b> per capire a che punto si era fermato il <b>Transport Trolley</b> per poter calcolare quelli che deve ancora fare,
        ma di lasciare il compito all'infrastruttura che il <b>basicrobot23</b> offre.<br><br>
        Nota importante: l'evento alarm viene recepito direttamente dal <b>basicrobot23</b> ma bisogna occuparsi comunque di inviare al <b>Transport Trolley</b> tale informazione per 
        informarlo dell'accaduto, siccome la reply del <b>moverobot(coordinate)</b> in casi di fallimento non restituisce la loro causa.
        Per quanto riguarda invece la resume: il <b>Sonar</b> quando rileverà di nuovo una distanza che permetterà lo sblocco del <b>Transport Trolley</b> verrà emesso 
        un evento che il <b>Transport Trolley</b> riceverà e si impegnerà a risbloccare il robot dall'operazione che si era fermato, riprendendo così la sua routine.

        <br>
        <br>

        Siccome il <b>Led</b> è relativo esclusivamente allo stato del singolo <b>Transport Trolley</b> si ritiene lecito lasciare a lui il controllo del <b>Led</b>, utilizzando
        il pattern Observer che permette al <b>led</b> di venire notificato ogni volta che un cambio di stato a lui interessante succede. Il <b>led</b> deve considerare anche quando
        il robot è fermo perché sta caricando/scaricando il carico. Quindi il <b>led</b> deve rimanere aggiornato sia dal <b>transport trolley</b> che dal <b>warningdevice</b>, 
        proprio per questo fatto di aver bisogno di ascoltare più attori si è deciso di adottare questo pattern. Utilizzando coap come protocollo di invio messaggi per il nostro
        <b>pattern Observer</b>, siccome facente parte integrante del QAK, c'è il rischio remoto che qualche messaggio vada perso dato che si utilizza il protocollo di trasporto 
        UDP. Non si valuta questo problema come critico in quanto la perdita di notifica di uno stato comprometterebbe il comportamento del <b>led</b> solo per breve tempo(indicativamente 3 secondi data la stanza presa in analisi), cioè fino 
        a quando non viene ricevuta un altra notifica
        <div class="remark">
            <div class="keypoint">Il <b>Transport Trolley</b> è l'incaricato di gestire il <b>Led</b> adottando il pattern Observer</div>
        </div>

        Il <b>Sonar</b>, invece, emetterà un evento e che il <b>Transport trolley</b> capterà e valuterà. La scelta di emettere un evento per il <b>Sonar</b> è motivata
        dal pensiero lungimirante, a favore dell'estendibilità, di avere in futuro molteplici <b>Transport Trolley</b> e dal fatto che la nostra software house sia già
        in possesso di materiale utilizzabile per questo scopo tramite il protocollo <a href="https://mqtt.org/">MQTT</a>. Un protocollo adatto per contesti IoT dove sono coinvolti sensori, attuatori
        e microcontrollori di potenza ridotta. Così facendo si fa in modo che il <b>Raspberry</b> invii esternamente tutti i valori che rileva ed il <b>ColdStorageService</b>
        si occuperà di sfoltirli, evitando di appesantire il <b>Raspberry</b>.
        <br><br>
        In particolare si valuta di adottare più attori, ognuno con uno scopo ben preciso:
        <ul>
            <li>Un attore per il <b>Sonar</b> che si occupa di misurare le distanze e comunicarle tutte sul canale</li>
            <li>Un attore che filtra tutte le misurazioni prodotte dal <b>Sonar</b> e filtrare solo quelle che no appartengono al range che il <b>sonar</b> è in grado di rilevare</li>
            <li>Un attore che ha come compito quello di notificare al <b>Transport Trolley</b> quando una distanza minore di <b>DLIMT</b> viene misurata</li>
        </ul>
        Questi tre attori messi assieme adottano il <b>pattern pipeline</b>, dove l'attore successivo consuma l'output di quello precedente.
        <div class="remark">
            <div class="keypoint">Gestione delle misurazioni ripartita tra tre attori</div>
        </div>

        <h3>Interazioni</h3>
        <table id="myTable">
            <thead>
                <tr>
                    <th>Messaggio</th>
                    <th>Mittente</th>
                    <th>Destinatario</th>
                    <th>Semantica messaggio</th>
                    <th>Descrizione</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>coapUpdate</td>
                    <td>transportrolley</td>
                    <td>warningdevice</td>
                    <td>Dispatch</td>
                    <td>Semantica <u>Dispatch</u> perchè informa al <b>warning device</b> lo stato che il 
                    <b>led</b> deve assumere adottando il <b>pattern Observer</b>.</td>
                </tr>
                <tr>
                    <td>alarm</td>
                    <td>alarmdevice</td>
                    <td>transportrolley <br> basicrobot
                    </td>
                    <td>Event</td>
                    <td>Semantica <u>Event</u> perchè informa a chi interessato che il robot si deve fermare.</td>
                </tr>

                <tr>
                    <td>obstacle</td>
                    <td>distancefilter</td>
                    <td>alarmdevice</td>
                    <td>Event</td>
                    <td>Semantica <u>Event</u> che fa parte della pipeline dei gestori delle misurazioni del <b>sonar</b>
                    che in questo caso notifica ad <b>alarmdevice</b> che la distanza misurata ed inferiore alla soglia
                    prestabilita <b>DLIMT</b>.</td>
                </tr>
                <tr>
                    <td>obstaclefree</td>
                    <td>distancefilter</td>
                    <td>alarmdevice</td>
                    <td>Event</td>
                    <td>Semantica <u>Event</u> che fa parte della pipeline dei gestori delle misurazioni del <b>sonar</b>
                        che in questo caso notifica ad <b>alarmdevice</b> che la distanza misurata ed superiore alla soglia
                        prestabilita <b>DLIMT</b>.</td>
                </tr>

                <tr>
                    <td>resume</td>
                    <td>warningdevice</td>
                    <td>transportrolley</td>
                    <td>Event</td>
                    <td>Semantica <u>Event</u> che serve al <b>transportrolley</b> per capire quando può far ripartire
                    il robot.</td>
                </tr>
            </tbody>
        </table>

        <h3>Architettura logica</h3>
        <div class="remark">
            Codice QAK per la modellazione del sistema: <a
                href="./sprint3.coldstorageservice/src/SonarLed.qak"
                target="_blank">SonarLed.qak</a>
        </div>

        Il sistema da noi modellato, presenta la seguente architettura logica:[NON E' FINALE! MANCA LA GUI][manca anche il resume event]
        <center>
            <div class="piccola">
                <img src="./sprint3/coldstorageservice_sprint3arch.png" alt="architettura logica">
            </div>
        </center>
        Siccome non compreso nell'immagine, si esplicita il fatto che l'evento alarm giunge anche al <b>basicrobot23</b>, il quale alla sua ricezione ferma il robot.<br>
        Inoltre per il momento si può adottare un <b>sonar</b> simulatore che genera misure a scelta, e successivamente un <b>sonar</b> fisico.

        <h2>Test plans</h2>
        <table id="myTable1">
            <thead>
                <tr>
                    <th>Test</th>
                    <th>Entità coinvolte</th>
                    <th>Scenario</th>
                    <th>Comportamento atteso</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>
        </table>

        <h2>Project</h2>
        Siccome nell'analisi del problema si è utilizzato un simulatore del <b>sonar</b> per creare il QAK, il passo successivo è quello di integrarne uno fisico.
        Per fare ciò si adotta un borker gratuito e a disposizione di tutti come <u>tcp://mqtt.eclipseprojects.io</u> che permette l'invio e la ricezione di eventi
        tra dispositivi fisicamente non collegati ma connessi alla rete internet.<br>
        Per comunicare dati utilizzando <b>MQTT</b> bisogna definire un topic che definisce il canale di utilizzo, utile per organizzare canali logici al solo fine di 
        poter distinguere categorie di eventi che vogliamo raggruppare o meno. Nel nostro caso si è adtootato <b>unibo/sonar/events</b> come topic per comunicare i dati
        dal <b>Raspberry</b> al <b>ColdStorageService</b>, il quale si impegna a ricevere le misurazioni "grezze" del <b>sonar</b> e prima di considerarle vengono 
        un po lavorate da:
        <ul>
            <li><b>SonarMQTTReceiver</b>: si impegna a ricevere i dati "grezzi" del <b>sonar</b> tramite MQTT e poi propaga l'evento all'interno del contesto ctx_coldstorage</li>
            <li><b>DataCleaner</b>: pulisce i valori scartando le misurazioni che non sono comprese in un range che va da 2 a 150 cm</li>
            <li><b>DistanceFilter</b>: riceve i dati puliti dal <b>DataCleaner</b> e invia un evento <b>obstacle</b> o <b>obstaclefree</b> qualora le misurazioni rispettivamente siano inferiori di <b>DLIMT</b> 
            oppure maggiori</li>
        </ul>
        Per finire la catena: gli eventi <b>obstacle</b> e <b>obstaclefree</b> sono eventi che l'<b>alarm device</b> è in grado di captare e, qualora le condizioni riguardanti 
        il tempo <b>MINT</b> tra uno stop e l'altro siano soddisfatte, emette un evento alarm che verrà ricevuto sia da <b>basicrobot23</b> sia dal <b>transportrolley</b>.
        <br><br>
        Anche per comunicare con il <b>led</b> si utilizza MQTT, mandando un messaggio con l'ausilio di un <b>UN ATTORE SCRITTO IN KOTLIN??</b> ed utilizzando 
        <b>unibo/led/events</b> come topic.
        <br><br>
        Per la fase di prototipazione il <b>sonar</b> e <b>led</b> saranno collegati ad un <b>Raspberry</b> tramite dei cavetti jumper femmina-femmina.
        <br>
        Il Software lato <b>Raspberry</b> sarà organizzato nella seguente maniera:
        <ul>
            <li>Un programma python che si occupa di utilizzare il <b>sonar</b> per estrapolare le distanze misurate</li>
            <li>Un programma python che cattura tali dati da standard input e scatena degli eventi al borker e topic citati nei paragrafi precedenti</li>
        </ul>
        Per definizione i due programmi devono essere eseguiti in pipe, es. : <u>python sonar.py | python controllerMQTT.py</u> 
        <br><br>
        Qui vengono riportati i file che definiscono il software necessario per il <b>Raspberry</b>: <a href="./sprint3/sonar.py">sonar.py</a> <a href="./sprint3/ControllerMqtt.py">controllerMQTT</a>
        <br><br>
        La scelta di Python è motivata dal fatto che si presenta un linbguaggio ideale per la prototipazione: rapido, con molte librerie di supporto e ben documentato.
        Successivamente se si desiderano performace migliori si può pensare di ottimizzare scrivendo codice di più basso livello.
        <br><br>
        I pin del <b>Raspberry</b> coinvolti sono:
        <ul>
            <li><b>GPIO 4</b>: pin TRIG sonar</li>
            <li><b>GPIO 27</b>: pin ECHO sonar</li>
            <li><b>GPIO 25</b>: pin led</li>
        </ul>



        
        <h2>Conclusioni</h2>
        
        <div class="remark">
            Gli output dello sprint3 sono:<br>
            <ul>
                <li>warning device</li>
                <li>alarm device</li>
            </ul>
            Implementati all'interno di una scheda Raspberry Pi.
        </div>

        <h4>Goals Sprint 4</h4>
        Si possono definire in seguito i goal relativi allo Sprint4:<br>
        <ol>
            <li></li>
        </ol>

        <br /><br />

        <div style="background-color:rgba(86, 56, 253, 0.9); width:60%; text-align:left;color:white">
            By <br>Tassinari Gabriele, email: gabriele.tassinari2@studio.unibo.it<br>
            Baraldi Leonardo, email: leonardo.baraldi@studio.unibo.it<br>
            Koss Krystian, email: krystian.koss@studio.unibo.it<br>
            <div class="foto">
                <img src="./common/gabriele.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./common/Baraldi.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./common/kriss.jpeg" alt="mbot" width="15%" height="15%">
            </div>
            <br>
            GIT repo: https://github.com/4utotune/ColdStorageService/ <br>
        </div>
</body>

</html>