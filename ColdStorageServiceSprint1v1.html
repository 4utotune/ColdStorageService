<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body {
        margin-left: 30px;
        margin-right: 30px;


        counter-reset: css-counter 0;
    }

    .keypoint {
        counter-increment: css-counter 1;
    }

    .keypoint:before {
        content: "Keypoint-" counter(css-counter)" ";
        /* font-style: italic; */
        font-weight: bold;
    }

    ;

    P {
        font-family: Tahoma;
        font-size: 10pt;
    }

    ;

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }

    a:hover {
        background-color: #cccccc;
    }


    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }

    h1,
    h2,
    h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }

    top {
        width: 100%;
    }


    #i {
        color: #ff1010;
    }

    tt {
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }

    em {
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style: solid;
        border-color: #abe876;
        color: #1632cc;
    }

    bc {
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
    }

    ks {
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD;
        font-size: 90%;
    }

    kc {
        font-family: "Arial";
        font-weight: bold;
        color: #008000;
        font-size: 90%;
    }

    pre {
        font-family: "Consolas";
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }

    m {
        font-family: "Helvetica";
        line-height: 100%;
        font-size: 75%;
    }

    div.body {

        font-size: 18px;
    }

    k {
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }

    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }

    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }

    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }

    h4 {
        background-color: #ccffcc;
        font-size: 100%;
        width: 95%;
        border-radius: 5px;
        padding: 2px;
    }

    h5 {
        background-color: #d5ffb0;
        font-size: 100%;

    }

    div.req {
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }

    div.remark {
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }

    table {
        width: 90%;
    }

    table,
    th,
    td {
        border: 1px solid black;
        border-collapse: collapse;
    }

    ol,
    ul,
    li {
        margin: 0;
        margin-left: 10px;
        padding: 0;
        padding-bottom: 5px;
    }

    table,
    th,
    td {
        border: 1px solid black;
    }

    img {
        border: 1.5px solid #d5f2ed
    }

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }

    div.wrapdesc {
        width: 90%;
        margin: auto;
    }

    div.imagedesc {
        width: 85%;
        margin: auto;
    }

    .piccolo {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 40%;
    }

    .piccola {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 50%;
        height: auto;
    }

    .piccola img {
        border-radius: 20px;
        max-width: 100%;
        max-height: 100%;
    }

    .piccolo img {
        border-radius: 20px;
        max-width: 100%;
        max-height: 100%;
    }

    .foto {
        margin: 0px;
        padding: 0px;
        display: flex;
        flex-direction: row;
        align-items: center;
        width: 100%;
        object-fit: fill;
    }

    .foto img {
        border-radius: 20px;
        max-width: 100%;
        height: 8em;
    }

    #myTable tbody tr:nth-child(odd) {
        background-color: lightgray;
    }

    #myTable td:first-child {
        background-color: rgb(81, 145, 233);
    }

    #myTable td:nth-child(-n+4) {
        text-align: center;
        font-weight: bold;
    }
</style>

<head>
    <title>Sprint1TKB</title>
</head>

<body>

    <div id="top">

        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE<font size="5"></font>
        </h1>

    </div>

    <div class="body">

        <h2>Introduction</h2>
        Lo <b>Sprint1</b> si impegna ad analizzare il core-business identificato dallo Sprint0, identificato dai
        componenti <b>Transport Trolley</b> e <b>ColdStorageService</b>.
        Ci occupiamo dunque di analizzare il sistema relativamente alla gestione del TransportTrolley, in particolare
        durante le operazioni di "goToINDOOR" e "goToPORT". <br>

        A tal fine i macro-componenti <b>ColdStorageService</b> e <b>Transport Trolley</b> vanno approfonditi
        identificando punti critici
        e valutando i costi di eventuali soluzioni.

        <h2>Requirements</h2>

        <div class="remark">
            <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Descrizione del
                TemaFinale23</a><br>

            <bc>Goals dello Sprint1</bc>:
            <ol>
                <li>Identificare ed analizzare tutti i problemi relativi ai requisiti che coinvolgono
                    <b>ColdStorageService</b> e <b>Transport Trolley</b>
                </li>
                <li>Formulare un modello del sistema composto dal <b>ColdStorageService</b> e dal <b>Transport
                        Trolley</b> e quindi fornire un'architettura logica del sistema</li>
                <li>Realizzare ai fini di test un simulatore in grado di interfacciarsi con il sistema</li>
                <li>Testare il sistema</li>
            </ol>

        </div>

        <h2>Requirement analysis</h2>
        <h5>Chiarimenti del committente</h5>
        L'interazione con il committente ha permesso di chiarire alcuni aspetti del progetto:
        <ul>
            <li>Qualora un <b>Fridge Truck </b> debba scaricare un carico superiore alla portata massima
                del <b>Transport Trolley</b> per il momento si adotta la politica di rifiutare a priori tale
                richiesta.<br>
                Il committente richiede tuttavia un'analisi dei costi relativa allo scenario in cui il <b>Transport
                    Trolley</b>
                accetti carichi che superano la sua capacità massima di carico, obbligandolo così ad effettuare più giri
                per soddisfare la richiesta di store.
            </li>
            <li>Quando il <b>Transport Trolley</b> ha completato tutte le richieste al momento presenti nel sistema
                torna alla
                <b>HOME</b>.
                Se durante il tragitto dalla <b>ColdRoom</b> alla <b>HOME</b> si presenta una nuova richiesta di azione
                di carico e scarico il
                <b>Transport Trolley</b>
                deve avere l'accortezza di direzionarsi direttamente alla <b>INDOOR</b>, senza quindi passare prima
                dalla <b>HOME</b>.
            </li>
            <li>Il <b>Transport Trolley</b> per raggiungere una determinata posizione della <b>Service Area</b> non deve
                per forza percorrere sempre la strada ottimale,
                ma non dovrebbe nemmeno fare giri particolarmente inefficienti. Quindi come conclusione vi è un minimo
                di tolleranza nei suoi spostamenti.</li>
        </ul>
        <h5>Chiarimenti con il committente</h5>
        Al committente piace questa gestione dei Ticket? <br>
        Problematica: <br>
        Se un conducente errando inesrisce il Ticket di un altro conducente, il sistema non è in grado di riconoscere l'errore e, supponendo che i due conducenti trasportino un peso diverso, verrà conseguentemente visualizzato un peso errato della Cold Room. <br>
        Possibile Soluzione: <br>
        Il conducente oltre ad inserire il Ticket, inserisce anche un secondo valore, come ad esempio il peso del carico che sta trasportando.
        <h5>Sistema</h5>
        Lo Sprint1 prevede l'interazione tra due componenti principali: <b>ColdStorageService</b> e <b>Transport
            Trolley</b>. <br>
        Ai fini di test includiamo nelle interazioni anche la ServiceAccessGUI che rappresenta in questo Sprint in
        componente proattivo che fungerà dunque da simulatore.
        Questa verrà analizzata nello Sprint successivo, ovvero lo Sprint2. <br>
        <center>
            <img src="./ServiceArea232.png" alt="sistema">
        </center>
        <h3>Analisi</h3>
        Dai requisiti espressi nel <a target="_blank" href="http://calendar.altervista.org/TemaFinale23.pdf">Tema
            Finale</a> e dall'analisi
        già effettuata nello Sprint0, in questo Sprint occerre analizzare le entità:
        <ul>
            <li><b>ColdStorageService</b>: che si occupa di gestire le richieste di store e i movimenti del Transport
                Trolley</li>
            <li><b>Transport Trolley</b>: gestisce le richieste del ColdStorageService ed invia comandi di più basso
                livello al BasicRobot23</li>
            <li><b>BasicRobot</b>: entità che riceve comandi dal Transport Trolley e guida il DDR-Robot (Virtual Robot
                che è la parte Tecnology Dependent)</li>
        </ul>
        <h5>Service Area (Requisito 1)</h5>
        Data la descrizione della stanza e l'immagine fornita dal committente, si è deciso di modellare la Service Area
        come un rettangolo, circoscritto da 4 mura,
        contentente due ostacoli fissi di cui uno è la Cold Room. <br>
        <center>
            <img src="./ServiceArea23.jpg" alt="service area"><br>
        </center>
        La stanza, di cui la mappa è fornita dal committente, presenta 4 zone rilevanti:
        <ul>
            <li><b>HOME</b>: area della stessa dimensione del Transport Trolley, in cui il TransportTrolley si trova
                all'avvio del sistema</li>
            <li><b>INDOOR</b>: zona lungo il perimetro, dove il TransportTrolley deve recarsi all'arrivo di una
                insertticket valida</li>
            <li><b>Port</b>: zona posizionata su un ostacolo che identifica il punto di scambio tra il TransportTrolley
                e la ColdRoom</li>
        </ul>
        <h5>TransportTrolley e DDR-Robot (Requisito 2)</h5>
        Il TransportTrolley e il DDR-Robot sono due entità distinte, ma che interagiscono tra loro, per effettuare le
        operazioni di carico e scarico. <br> In particolare:
        <ol>
            <li>Carico della merce presso l'INDOOR</li>
            <li>Trasporto della merce dall'INDOOR alla PORT</li>
            <li>Scarico della merce presso la PORT</li>
        </ol>
        <h5>Note</h5>
        Il committente ci fornisce:
        <ul>
            <li>La mappa della stanza</li>
            <li>BasicRobot</li>
        </ul>
        <h2>Analisi del Problema</h2>
        L'esplorazione del core-business del servizio porta all'analisi dei due macro componenti,
        <b>TransportTrolley</b> e <b>ColdStorageService</b>, a cui corrispondono indipendenti discussione dei problemi
        ed osservazioni.
        <h3>Transport Trolley</h3>
        Il committente mette a disposizione il <a href='BasicRobot23.html'>BasicRobot23</a> che permette di
        guidare il <b>DDR-robot</b>.
        Questo componente risulta decisamente utile poichè ci permette di riciclare tutto il codice già presentato ed
        analizzato a lezione.
        Ovvero ci permette di introdurre il concetto di griglia e dunque ci risulta possibile identificare la posizione
        del TransportTrolley e degli ostacoli all'interno della mappa, non più con i path e dunque
        i classici comandi come: vai avanti,
        vai indietro, gira a destra di 90° e gira a sinistra di 90°, bensì con delle cordinate.
        <br>
        (<a href='BasicRobot23.html#basicrobot23-le-funzioni'>Raccolta di tutti i comandi
            utilizzabili sul BasicRobot23</a>)<br>
        Il <u>BasicRobot</u> ci fornisce infatti un Mapper che ci permette di mostrare la mappa della stanza come una
        griglia, un Planner
        che individua il path che il DDR-Robot deve percorre per raggiungere un determinata posizione (evitando gli
        ostacoli) ed un Path Executor che esegue il path calcolato dal planner.
        <br>
        È dunque possibile rappresentare la mappa della stanza come una Matrice MxN, ovvero come una griglia di
        coordinate.
        <center>
            <img src="./ServiceArea23Griglia.jpg" alt="service area"><br>
        </center>
        <br>
        È dunque ora possibile identificare la posizione del TransportTrolley e degli ostacoli all'interno della mappa:
        <ul>
            <li><b>HOME -> (0,0)</b></li>
            <li><b>INDOOR -> (0,4)</b></li>
            <li><b>PORT -> (4,3)</b></li>
            <li><b>OSTACOLO -> (2,3)</b></li>
        </ul>
        Nel caso in cui il TransportTrolley, dopo aver scaricato la merce presso la Cold Room, si stia dirigendo verso
        la Home e durante il tragitto riceva una richiesta di store, il TransportTrolley dovrà, tramite il Planner
        identificare la strada corretta per raggiungere l'INDOOR. <br>


        <h3>ColdStorageService</h3>
        Per quanto riguarda i meccanismi di gestione delle richieste in arrivo, le problematiche da affrontare sono
        principalmente tre.
        <h5>1 - Concomitanza di richieste da parte di Fridge Truck diversi</h5>
        Il committente a seguito della review dello Sprint0 ha confermato che i Ticket vengono inseriti dai conducenti
        dei Fridge Truck solo presso la zona Indoor.<br>
        Ciò lascia comunque la questione di un eventuale inserimento di più Ticket da parte di più conducenti dei Fridge
        Truck nel caso in
        cui l'INDOOR presenti più postazioni e dunque più conducenti vengano serviti in contemporanea. Si è deciso di
        non permettere questa opzione, e quindi i conducenti dei Truck devono mettersi "in
        coda" in attesa del proprio turno. Questo perchè:
        <ul>
            <li>il sistema è in grado di servire un carico per volta</li>
            <li>nell'attesa del completamento della richiesta del primo Truck in fila, altri potrebbero andare oltre il
                limite di tempo del proprio Ticket, che però essendo già stato inserito (e confermato) risulterà ancora
                valido. </li>
        </ul>
        <div class="remark keypoint">Il sistema non ammette una coda di Truck alla zona Indoor.</div>

        Dopo che il Transport Trolley da conferma al Fridge Truck tramite messaggio "charge taken" di aver preso in
        carico la richiesta, si dirige verso la ColdRoom impiegando un certo tempo. Il Fridge Truck è allora libero di
        lasciare la zona INDOOR, e quindi il servizio potrebbe accettare un nuovo Ticket.<br>
        Individuamo quindi due Ticket che in contemporanea ColdStorageService può gestire:<ul>
            <li>quello relativo al carico che il Transport Trolley sta trasportando -> WorkingTicket</li>
            <li>quello del Fridge Truck in attesa alla zona INDOOR -> WaitingTicket</li>
        </ul>
        <div class="remark keypoint">Il sistema può accettare un Ticket mentre il TransportTrolley sta ancora
            terminando la richiesta
            del precedente. Il servizio perciò gestisce al massimo due Ticket contemporaneamente.
        </div>


        La sequenza di interazioni è quindi la seguente:
        <ol>
            <li>Quando un Fridge Truck inserisce il proprio Ticket, nel caso il servizio dia conferma di validità, viene
                chiesto
                al TransportTrolley di recarsi presso la zona carico. In questo caso diciamo che il Ticket è in attesa
                (Waiting).</li>
            <li>Quando il Trolley da conferma di Charge Taken e si dirige verso la ColdRoom, il Ticket viene segnato
                come in lavorazione (Working) e il Fridge Truck è libero di abbandonare la zona INDOOR.
            </li>
            <li>
                In questo momento un'altra richiesta di inserimento Ticket può essere gestita dal sistema. Questo
                nuovo Ticket rimarrà in stato Waiting fino a che il TransportTrolley non avrà depositato il carico
                corrente e richiesto al servizio se è presente un nuovo Ticket.
            </li>
        </ol>
        <div class="remark keypoint">Si può pensare che il TransportTrolley comandi indirettamente il passaggio dei
            Ticket da Waiting a
            Working, comunicando
            a ColdStorageService quando ha preso il carico dal Truck e quando lo ha depositato nella ColdRoom.</div>
        <!--
        Esempio:
        <ol>
            <li>Robot Idle -> Waiting null Working null</li>
            <li>Truck in attesa arrivo Robot -> Waiting T1 Working null</li>
            <li>Charge taken -> Waiting null Working T1</li>
            <li>Nuovo Truck mentre Robot non ancora a Cold Room -> Waiting T2 Working T1</li>
            <li>Robot deposita -> Waiting T2 Working null</li>
            <li>Charge taken -> Waiting null Working T2</li>
        </ol>
    -->

        <h5>2 - gestione stato ColdRoom e richieste di storage</h5>
        Dato il tempo materiale di spostamento del carico da INDOOR a ColdRoom dovuto al movimento del
        TransportTrolley, e il grado di variabilità nel tempo tra richiesta di storage e inserimento del
        Ticket da parte dei Fridge Truck, serve una strategia per l'aggiornamento della capacità della ColdRoom
        stessa.<br>
        Non possiamo dare per scontato che ogni scarico vada a buon fine: un Truck potrebbe chiedere un Ticket e non
        presentarsi
        mai, oppure il Ticket stesso potrebbe scadere. Anche nel caso in cui la richiesta venga correttamente presa in
        carico,
        potrebbe comunque verificarsi un malfunzionamento al Transport Trolley che gli impedisca di arrivare alla Cold
        Room e dunque di terminare l'azione di carico e scarico.
        Il momento ideale per aggiornare il peso all'interno della ColdRoom è per ciò a termine di un deposito avvenuto
        con successo.
        <div class="remark keypoint">La quantità contenuta nella ColdRoom va aggiornata a deposito avvenuto.</div>

        Ciò però pone un altro problema: se un Truck richiede di scaricare un certo peso prima che vengano completate le
        altre
        richieste, si potrebbe verificare una situazione di "overbooking" della ColdRoom.<br>
        Decidiamo di considerare ogni richiesta di Storage non ancora completamente soddisfatta come una prenotazione di
        una
        certa quantità di peso nel frigo. Il controllo all'arrivo di ogni richiesta di store prenderà in considerazione
        sia il
        peso effettivo che quello prenotato. Nel caso in cui la ColdRoom appaia teoricamente piena, il servizio prima di
        respingere la richiesta ha premura di controllare eventuali Ticket scaduti, e conseguentemente liberare lo
        spazio
        allocato. Qualora non siano presenti Ticket scaduti, la richiesta verrà respinta.<br>
        Questo meccanismo potrà portare il servizio a respingere carichi che in breve tempo si sarebbero rivelati
        accettabili, ma si tratta di casi molto rari. Con questo sistema di allocazione logica del peso siamo sicuri di
        non mandare mai il servizio in stato di overbooking, accettando solo richieste che si è sicuri di poter
        gestire.<br>
        Solo quando il TransportTrolley avrà comunicato di aver depositato nella ColdRoom il carico che attualmente sta
        gestendo verrà aggiornato il peso del contenuto reale del frigo e di conseguenza deallocato quello
        prenotato.<br>

        <div class="remark">
            <div class="keypoint">I Ticket hanno anche la funzione di prenotazione di spazio all'interno della
                Cold Room</div>
            <div class="keypoint">La validità dei <b>Ticket</b> può essere verificata solo quando tale informazione
                potrebbe influenzare l'accettazione dei <b>Fridge Truck</b> successivi.</div>
        </div>

        Il <b>ColdStorageService</b> deve essere l'unico componente cosciente dei <b>Ticket</b>, quindi tutti quelli che
        vogliono trarne delle informazioni devono riferirsi a lui.

        <div class="remark keypoint">I Ticket sono univocamente distinti da una sequenza di numeri pari al timestamp
            di quando la
            richiesta è stata effettuata, e vengono gestiti unicamente da ColdStorageService.
        </div>

        <h5>3 - comunicazione con TransportTrolley</h5>
        Essendo il <b>Transport Trolley</b> l'entità che si occupa di muovere il DDR-Robot e che quindi è a
        conoscenza del metodo di rappresentazione a
        coordinate della <b>Service Area</b>, è consigliabile la <b>ColdStorageService</b> gestisca solo le richieste ad
        alto livello e dunque
        non sia a conoscenza delle coordinate. Così facendo la
        <b>ColdStorageService</b> si occuperà
        di gestire le richieste e comandare il <b>Transport Trolley</b>, senza esplicitare le coordinate,
        ovvero tramite i comandi:
        <ul>
            <li>Andare in <b>INDOOR</b>, per soddifare la richiesta di un <b>Fridge Truck</b></li>
            <li>Andare in <b>HOME</b>, se non ci sono <b>Fridge Truck</b> da servire</li>
        </ul>

        Si noti che la <b>ColdStorageService</b> non possiede il comando <u>Andare in <b>PORT</b></u>. Questo è
        dovuto al fatto che il <b>ColdStorageService</b> comunica al <b>Transport Trolley</b> che deve servire un
        <b>Fridge Truck</b>, dando per scontato che i
        viaggi saranno due:
        <ul>
            <li>Da dove si trova alla <b>INDOOR</b> per caricare gli alimenti</li>
            <li>Dalla <b>INDOOR</b> alla <b>PORT</b></li>
        </ul>

        <div class="remark keypoint">ColdStorageService ha una visione astratta della zona di movimento del Robot: ne
            conosce solo i punti di interesse.
        </div>

        Ricordiamo che per il momento il committente desidera un servizio che rifiuti i <b>Fridge Truck</b> che
        richiedano
        uno scarico di
        alimenti che supera la portata
        massima del <b>Transport Trolley</b>. Quindi, quando la <b>ColdStorageService</b> ordina al <b>Transport
            Trolley</b> di caricare/scaricare
        un carico, lo effettua senza passarli alcun parametro. Questo andrebbe contraddetto nel caso il sistema
        accettasse
        carichi da parte dei <b>Fridge truck</b> che
        superano la portata massima del robot, obbligandolo ad effettuare più giri per la medesima richiesta. In
        questo caso infatti bisognerebbe tenere conto del peso totale di carico da trasportare, in modo da riuscire ad
        identificare il
        numero di giri necessario per soddisfare la richiesta. Il Committente ha richiesto una <u>analisi dei costi</u>
        per valutare successivamente se supportare anche questa
        casistica.<br>
        <h5>Analisi dei costi</h5>
        <ul>
            <li><b>Complessità</b>: il sistema risulterebbe di maggiore complessità rispetto al modello creato.
                Occorrerebbe infatti aggiungere
                la logica riguardante il numero di giri che il Transport Trolley deve fare. Occorrerebbe anche valutare
                se la decisione sul numero di giri da effettuare
                debba essere di competenza della ColdStorageService o del TransportTrolley.
            </li>
            <li>
                A livello prettamente economico il sistema risulterebbe meno redditizio per il Committente, poichè il
                TransportTrolley impiegherebbe più tempo per
                soddisfare una richiesta, e quindi il numero di richieste soddisfatte in un'unità di tempo sarebbe
                minore. Dunque se i FridgeTruck portano allo stesso
                guadagno indipendentemente dal peso del carico, il sistema risulterebbe meno redditizio.
            </li>
            <li>
                Effettuando più giri occorrerebbe stimare la tempistica media di un giro del TransportTrolley, in modo
                da poter stimare il tempo di attesa di un FridgeTruck e dunque riuscire
                a stimare il Ticket Exipartion Time in modo da far scadere il minor numero di Ticket possibile. Questo
                andrebbe a complicare la logica di gestione dei Ticket.
            </li>
        </ul>
        <div class="remark keypoint">Per il momento qualunque richiesta eccedente il peso massimo trasportabile dal DDR
            Robot verrà respinta</div>

        <h5>Inserimento Ticket</h5>
        Nello scenario in cui un conducente inserisce un Ticket errato, ovvero quando
        durante l'inserimento del Ticket, il conducente, effttuando un errore di battitura, carica un Ticket inesatto. In questo caso, il sistema 
        respinge la richiesta del conducente il quale dovrà abbandonare l'INDOOR.
        <div class="remark keypoint">Il sistema fornisce indicazioni al conducente sul motivo per cui la
            richiesta è stata respinta
        </div>


        <h3>Interazioni</h3>




        <table id="myTable">
            <thead>
                <tr>
                    <th>Messaggio</th>
                    <th>Mittente</th>
                    <th>Destinatario</th>
                    <th>Semantica messaggio</th>
                    <th>Descrizione</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>insertticket</td>
                    <td>ServiceAccessGUI</td>
                    <td>ColdStorageService</td>
                    <td>Request</td>
                    <td>Semantica Request perché all'inserimento del ticket il conducente del <b>Fridge Truck</b> deve
                        sapere immediatamente
                        l'esito dell'inserimento. Conterrà il numero del ticket inserito.</td>
                </tr>
                <tr>
                    <td>replyinsertticket</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Reply</td>
                    <td>Reply alla <u>insertticket</u>, conterrà l'informazione della validità del <b>ticket</b>
                        precedentemente inserito.</td>
                </tr>
                <tr>
                    <td>storerequest</td>
                    <td>ServiceAccessGUI</td>
                    <td>ColdStorageService</td>
                    <td>Request</td>
                    <td>Semantica Request perché il conducente del <b>Fridge Truck</b> vuole sapere immediatamente se
                        c'è posto per il suo carico.
                        La richiesta conterrà il numero di Kg del carico da scaricare.</td>
                </tr>
                <tr>
                    <td>replystorerequest</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Reply</td>
                    <td>Reply alla <u>storerequest</u>, conterrà il numero del <b>ticket</b> nel caso il carico sia
                        stato preso in considerazione,
                        altrimenti bisogna comunicare che la richiesta è stata rifiutata dal sistema.</td>
                </tr>
                <tr>
                    <td>chargedeposited</td>
                    <td>transporttrolley</td>
                    <td>ColdStorageService</td>
                    <td>Request</td>
                    <td>Semantica Request perchè quando il <b>Transport Trolley</b> comunica che ha scaricato il carico
                        alla <b>ColdRoom</b>
                        deve necessariamente sapere quale sarà la sua successiva mossa: se procedere alla <b>INDOOR</b>
                        per soddifare un altro
                        <b>Fridge Truck</b> oppure se andare in <b>HOME</b> perché non si sono rischieste sospese nel
                        sistema.
                    </td>
                </tr>
                <tr>
                    <td>replychargedeposited</td>
                    <td>ColdStorageService</td>
                    <td>transporttrolley</td>
                    <td>Reply</td>
                    <td>Reply alla <u>chargedeposited</u>, conterrà la prossima mossa del <b>Transport Trolley</b>: se
                        andare alla <b>INDOOR</b>
                        per soddifare un altro <b>Fridge Truck</b> oppure se andare in <b>HOME</b> perché non si sono
                        rischieste sospese nel sistema.</td>
                </tr>
                <tr>
                    <td>chargetaken</td>
                    <td>transporttrolley</td>
                    <td>ColdStorageService</td>
                    <td>Dispatch</td>
                    <td>Semantica Dispatch perché il <b>Transport Trolley</b> deve comunicare il fatto che abbia
                        caricato il carico che in quel momento
                        si trovava alla <b>INDOOR</b>, senza aspettarsi in cambio alcuna informazione.</td>
                </tr>
                <tr>
                    <td>chargetaken</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Dispatch</td>
                    <td>Il <b>ColdStorageService</b> propaga il messaggio <u>chargetaken</u> alla
                        <b>ServiceAccessGUI</b> in modo tale da informare il
                        conducente del <b>Fridge Truck</b> che il suo carico è stato preso dal <b>Transport Trolley</b>
                        e che quindi se ne può andare.
                    </td>
                </tr>
                <tr>
                    <td>gotoindoor</td>
                    <td>ColdStorageService</td>
                    <td>transporttrolley</td>
                    <td>Dispatch</td>
                    <td>Semantica Dispatch perché il <b>ColdStorageService</b> comunica al <b>Transport Trolley</b> di
                        occuparsi di soddisfare il
                        <b>Fridge Truck</b>. Mentre il <b>Transport Trolley</b> lavora il <b>ColdStorageService</b> deve
                        essere in grado di accettare
                        le richieste che arrivano nel frattempo.
                    </td>
                </tr>
                <tr>
                    <td>coldroomdata</td>
                    <td>ColdStorageService</td>
                    <td>ServiceAccessGUI</td>
                    <td>Dispatch</td>
                    <td>Semantica Dispatch perché il <b>ColdStorageService</b> comunica in maniera fire-and-forget alla
                        <b>ServiceAccessGUI</b> il
                        peso corrente della <b>ColdRoom</b> ogni volta che questo varia. Questo messaggio serve solo ad
                        informare la <b>ServiceAccessGUI</b>
                        del peso corrente della <b>ColdRoom</b>.
                    </td>
                </tr>




            </tbody>
        </table>

        <div class="remark">
            Codice QAK per la modellazione del sistema: <a
                href="./sprint0.coldstorageservice/src/ColdStorageService.qak"
                target="_blank">ColdStorageService.qak</a>
        </div>






        <h3>Architettura logica</h3>
        Il sistema da noi modellato, presenta la seguente architettura logica:
        <center>
            <div class="piccola">
                <img src="./sprint0.coldstorageservice/coldstorageservice_sprint0arch.png" alt="architettura logica">
            </div>
        </center>
        <h2>Test plans</h2>
        <b>Occorre verificare che tutti i Test soddisfino i requisiti del Committente</b>
        <table id="myTable1">
            <thead>
                <tr>
                    <th>Test</th>
                    <th>Entità coinvolte</th>
                    <th>Scenario</th>
                    <th>Comportamento atteso</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>MultipleRequestsHandling</td>
                    <td>ColdStorageService</td>
                    <td>Dalla <b>ServiceAccessGUI</b> vengono richieste alla <b>ColdStorageService</b> due richieste consecutive: un <b>insertticket</b> e successivamente,dopo aver
                        ricevuto il messaggio <b>replyinsertticket</b> di validità del <b>ticket</b>,
                    un <b>storerequest</b> con peso inferiore alla capacità massima del robot. Al fine di verificare se il sistema accetta richieste mentre si sta servendo una richiesta di un <b>Fridge Truck</b>.</td>
                    <td>La <b>ServiceAccessGUI</b> alla seconda richiesta di <b>storerequest</b> riceve una risposta affermativa.</td>
                </tr>
                <tr>
                    <td>TicketExpired</td>
                    <td>ColdStorageService</td>
                    <td>La <b>ServiceAccessGUI</b> richiede un <b>storerequest</b> e successivamente dopo <b>TICKETTIME</b> secondi invia la richiesta di <b>insertticket</b>.</td>
                    <td>La <b>ServiceAccessGUI</b> riceve un messaggio <b>replyinsertticket</b> che dichiara l'invalidità del <b>ticket</b>.</td>
                </tr>
                <tr>
                    <td>UpdateWeight</td>
                    <td>ColdStorageService</td>
                    <td>La <b>ServiceAccessGUI</b> richiede un <b>storerequest</b> con un carico di <b>FW</b> Kg e successivamente un <b>insertticket</b>.</td>
                    <td>Quando la <b>ColdStorageService</b> riceve <b>chargedeposited</b> ci si aspetta che il suo contatore del peso presente nella <b>ColdRoom</b> sia stato aggiornato con <b>FW</b> Kg in più.</td>
                </tr>
                <tr>
                    <td>TransportTrolleyServiceTruck</td>
                    <td>ColdStorageService<br>TransportTrolley</td>
                    <td>La <b>ColdStorageService</b> richiede tramite la <b>gotoindoor</b> al <b>Transport Trolley</b> di andare alla <b>INDOOR</b> per soddisfare una richiesta
                    di un <b>Fridge Truck</b>.</td>
                    <td>La <b>ColdStorageService</b> dopo un lasso di tempo non troppo lungo riceve un messaggio di <b>chargetaken</b> seguito,non immediatamente , da un messaggio <b>chargedeposited</b>.</td>
                </tr>
            </tbody>
        </table>

        <h2>Project</h2>
        Per implementare la gestione dei Ticket ed in particolare i Keypoint 1, 2, 3, 5 e 6, abbiamo deciso di utilizzare un
        classe java <b>Ticket</b> che contiene le informazioni relative al <b>ticket</b> stesso ed una classe java <b>TicketManager</b> che si occupa di gestire i <b>ticket</b>. <br>
        Entrambe le classi sono modellate come POJO (Plain Old Java Object), dove il TicketManager è stato implementato come Singleton.<br>
        <h5>Ticket.java</h5>
        Questa classe rappresenta il Ticket stesso, si occupa dunque di mantenere il Timestamp di creazione del Ticket (corrispondente ad un ID univoco) e il Timeout che rappresenta dopo quanto tempo il Ticket deve scadere.<br>
        In questa maniera, il tempo di scadenza del Ticket non solo risulta personalizzabile da parte del Committente, bensì è anche possibile esprimere diverse scadenze per Ticket diversi. Questa classe oltre ai metodi Setter e Getter, tipici dei POJO, presenta anche una funzione <b>isValid</b> che restituisce un booleano che indica se il Ticket è scaduto o meno, ovvero se la differenza tra il Timestamp attuale e quello generato al momento di creazione del Ticket 
        è maggiore o minore del tempo di scadenza.<br>
        Occorre utilizzare un SimpleDateFormat per la gestione del Timestamp, in particolare per la conversione da String a Date e viceversa.<br>
        <center>
            <div class="piccolo">
                <img src="./Ticket.png" alt="TicketSimpleDateFormat">
            </div>
        </center>
        <h6>UML Ticket</h6>
        <center>
            <div class="piccolo">
                <img src="./tickuml.png" alt="TicketUML">
            </div>
        </center>
        <h5>TicketManager.java</h5>
        Il TicketManager è la classe che gestisce i Ticket, e viene qui implementata come Singleton.
        Il TicketManager viene dunque istanziato all'interno della ColdStorageService, che è dunque l'unica che ha accesso ai Ticket.<br>
        Il TicketManager si occupa quindi di gestire i Ticket in base ai messaggi che riceve dalla ServiceAccessGUI, in particolare si occupa di creare i Ticket, di verificare la loro validità e di eliminarli una volta scaduti.<br>
        Per fare ciò il TicketManager contiene una lista di Ticket, che viene aggiornata in base ai messaggi ricevuti.<br>
        <center>
            <div class="piccolo">
                <img src="./Ticketmanager_list.png" alt="TicketManager">
            </div>
        </center>
        
        Per implementare la logica espressa nel Keypoint 3, ovvero il passaggio dei Ticket da Waiting a Working, vengono dichiarate due variabili private waiting e working di tipo String. Queste variabili mantengono i timestamp del biglietto in attesa e del biglietto in lavorazione rispettivamente. <br>
        Viene inoltre definito il metodo waitingNowWorking, che utilizza i metodi: isWorking, isWaiting, stopWorking e stopWaiting, per gestire la transizione del biglietto in attesa a quello in lavorazione. <br>
        Una volta gestito il Ticket, questo viene eliminato dalla lista dei Ticket. <br>
        <center>
            <div class="piccolo">
                <img src="./TicketManager_waiwork.png" alt="TicketManager2">
            </div>
        </center>
        
        <h6>UML TicketManager</h6>
        <center>
            <div class="piccolo">
                <img src="./tmuml.png" alt="TicketUML">
            </div>
        </center>
        
        <!-- 
        <h2>Testing</h2>


        <h2>Deployment</h2>


        <h2>Maintenance</h2>
-->
        <br /><br />

        <div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
            By <br>Tassinari Gabriele, email: gabriele.tassinari2@studio.unibo.it ,<br>
            Baraldi Leonardo, email: leonardo.baraldi@studio.unibo.it ,<br>
            Koss Krystian, email: krystian.koss@studio.unibo.it<br>
            <div class="foto">
                <img src="./gabriele.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./Baraldi.jpeg" alt="mbot" width="15%" height="15%">
                <img src="./kriss.jpeg" alt="mbot" width="15%" height="15%">
            </div>
            <br>
            GIT repo: https://github.com/4utotune/ColdStorageService/ <br>
        </div>
</body>

</html>